var search_data = {"index":{"searchIndex":["float","libxml","xml","attr","attrdecl","attributes","document","dtd","encoding","error","htmlparser","context","options","inputcallbacks","namespace","namespaces","node","parser","context","options","reader","relaxng","saxparser","callbacks","verbosecallbacks","schema","attribute","element","facet","type","types","writer","xinclude","xpath","context","expression","object","object","<<()","<=>()","==()","==()","[]()","[]()","[]()","[]()","[]=()","[]=()","add_scheme()","annonymus_subtypes()","annonymus_subtypes_recursively()","annotation()","annotation()","array?()","attribute?()","attribute_count()","attribute_decl?()","attributes()","attributes()","attributes?()","base()","base_uri()","base_uri()","base_uri()","base_uri=()","base_uri=()","blank?()","byte_consumed()","canonicalize()","catalog_dump()","catalog_remove()","cdata?()","check_lib_versions()","child()","child()","child()","child()","child?()","child?()","child?()","child?()","children()","children?()","clone()","close()","close()","close()","code_to_s()","column_number()","comment?()","compile()","compression()","compression=()","compression?()","content()","content=()","context()","context()","copy()","data_directory()","debug()","debug()","debug()","default()","default()","default?()","default_compression()","default_compression=()","default_prefix=()","default_save_no_empty_tags()","default_save_no_empty_tags=()","default_tree_indent_string()","default_tree_indent_string=()","definitions()","depth()","depth()","disable_cache()","disable_cdata=()","disable_cdata=()","disable_cdata?()","disable_sax?()","doc()","doc()","doc()","doc()","doc()","doc?()","doc?()","docbook?()","docbook_doc?()","doctype?()","document()","document()","document()","document()","document()","document()","document()","document()","document?()","domain_to_s()","dtd?()","dup()","each()","each()","each()","each()","each()","each()","each_attr()","each_attr()","each_child()","each_element()","each_sibling()","element?()","element_decl?()","elements()","elements()","elements()","empty?()","empty?()","empty_element?()","enable_cache()","enabled_automata?()","enabled_c14n?()","enabled_catalog?()","enabled_debug?()","enabled_docbook?()","enabled_ftp?()","enabled_html?()","enabled_http?()","enabled_iconv?()","enabled_memory_debug?()","enabled_regexp?()","enabled_schemas?()","enabled_thread?()","enabled_unicode?()","enabled_xinclude?()","enabled_xpath?()","enabled_xpointer?()","enabled_zlib?()","encoding()","encoding()","encoding()","encoding=()","encoding=()","end_attribute()","end_cdata()","end_comment()","end_document()","end_dtd()","end_dtd_attlist()","end_dtd_element()","end_dtd_entity()","end_element()","end_pi()","entity?()","entity_ref?()","eql?()","eql?()","errno()","expand()","external_id()","facets()","file()","file()","file()","file()","file()","file()","file()","file()","find()","find()","find()","find_by_href()","find_by_prefix()","find_first()","find_first()","first()","first()","first()","first?()","flush()","fragment?()","from_s()","from_string()","from_string()","full_end_element()","get_attribute()","get_attribute()","get_attribute_no()","get_attribute_ns()","get_attribute_ns()","get_handler()","has_attributes?()","has_value?()","href()","html?()","html_doc?()","import()","imported_ns_elements()","imported_ns_types()","imported_types()","indent_tree_output()","indent_tree_output=()","inner_xml()","io()","io()","io()","io()","io()","io()","io()","io()","io_max_num_streams()","io_num_streams()","keep_blanks?()","kind_name()","lang()","lang=()","last()","last()","last()","last()","last?()","last?()","last?()","length()","length()","level_to_s()","line_num()","line_number()","local_name()","lookup_namespace()","max_occurs()","memory_dump()","memory_used()","min_occurs()","move_to_attribute()","move_to_attribute_no()","move_to_attribute_ns()","move_to_element()","move_to_first_attribute()","move_to_next_attribute()","name()","name()","name()","name()","name()","name=()","name_depth()","name_depth_max()","name_node()","name_tab()","namespace()","namespace=()","namespace?()","namespace_declaration?()","namespace_uri()","namespaces()","namespaces()","namespaces()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_cdata()","new_comment()","new_pi()","new_text()","next()","next()","next()","next()","next()","next()","next=()","next?()","next?()","next?()","next?()","next_sibling()","node()","node()","node()","node()","node()","node()","node()","node()","node=()","node_depth()","node_depth_max()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type()","node_type_name()","node_type_name()","node_type_name()","node_type_name()","normalization()","notation?()","ns()","ns?()","num_chars()","on_cdata_block()","on_cdata_block()","on_characters()","on_characters()","on_comment()","on_comment()","on_end_document()","on_end_document()","on_end_element_ns()","on_end_element_ns()","on_error()","on_error()","on_external_subset()","on_external_subset()","on_has_external_subset()","on_has_external_subset()","on_has_internal_subset()","on_has_internal_subset()","on_internal_subset()","on_internal_subset()","on_is_standalone()","on_is_standalone()","on_processing_instruction()","on_processing_instruction()","on_reference()","on_reference()","on_start_document()","on_start_document()","on_start_element_ns()","on_start_element_ns()","options()","options=()","options=()","order_elements!()","output_escaping=()","output_escaping?()","parent()","parent()","parent()","parent()","parent?()","parent?()","parent?()","parent?()","parse()","parse()","parse()","path()","pi?()","prefix()","prefix()","prev()","prev()","prev()","prev()","prev=()","prev?()","prev?()","prev?()","prev?()","quote_char()","rb_encoding()","read()","read_attribute_value()","read_inner_xml()","read_outer_xml()","read_state()","read_string()","recovery=()","recovery?()","register()","register_error_handler()","register_namespace()","register_namespaces()","register_namespaces_from_node()","relax_ng_validate()","remove!()","remove!()","remove_scheme()","replace_entities=()","replace_entities?()","required?()","required?()","reset_handler()","result()","root()","root=()","save()","schema_validate()","set_handler()","set_indent()","set_indent_string()","set_quote_char()","sibling=()","siblings()","size()","space_depth()","space_depth_max()","space_preserve()","space_preserve=()","standalone()","standalone?()","standalone?()","start_attribute()","start_attribute_ns()","start_cdata()","start_comment()","start_document()","start_dtd()","start_dtd_attlist()","start_dtd_element()","start_dtd_entity()","start_element()","start_element_ns()","start_pi()","stats?()","string()","string()","string()","string()","string()","string()","string()","string()","string()","subset_external?()","subset_external_system_id()","subset_external_uri()","subset_internal?()","subset_internal_name()","system_id()","text?()","to_a()","to_a()","to_h()","to_h()","to_rb_encoding()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","to_s()","types()","uri()","url()","valid()","valid?()","validate()","validate?()","validate_relaxng()","validate_schema()","value()","value()","value()","value=()","version()","version()","well_formed?()","write_attribute()","write_attribute_ns()","write_cdata()","write_comment()","write_dtd()","write_dtd_attlist()","write_dtd_element()","write_dtd_entity()","write_dtd_external_entity()","write_dtd_external_entity_contents()","write_dtd_internal_entity()","write_dtd_notation()","write_element()","write_element_ns()","write_pi()","write_raw()","write_string()","xhtml?()","xinclude()","xinclude_end?()","xinclude_start?()","xlink?()","xlink_type()","xlink_type_name()","xml_lang()","xml_version()","xpath_type()","history","license","readme"],"longSearchIndex":["float","libxml","libxml::xml","libxml::xml::attr","libxml::xml::attrdecl","libxml::xml::attributes","libxml::xml::document","libxml::xml::dtd","libxml::xml::encoding","libxml::xml::error","libxml::xml::htmlparser","libxml::xml::htmlparser::context","libxml::xml::htmlparser::options","libxml::xml::inputcallbacks","libxml::xml::namespace","libxml::xml::namespaces","libxml::xml::node","libxml::xml::parser","libxml::xml::parser::context","libxml::xml::parser::options","libxml::xml::reader","libxml::xml::relaxng","libxml::xml::saxparser","libxml::xml::saxparser::callbacks","libxml::xml::saxparser::verbosecallbacks","libxml::xml::schema","libxml::xml::schema::attribute","libxml::xml::schema::element","libxml::xml::schema::facet","libxml::xml::schema::type","libxml::xml::schema::types","libxml::xml::writer","libxml::xml::xinclude","libxml::xml::xpath","libxml::xml::xpath::context","libxml::xml::xpath::expression","libxml::xml::xpath::object","object","libxml::xml::node#<<()","libxml::xml::namespace#<=>()","libxml::xml::error#==()","libxml::xml::node#==()","libxml::xml::attributes#[]()","libxml::xml::node#[]()","libxml::xml::reader#[]()","libxml::xml::xpath::object#[]()","libxml::xml::attributes#[]=()","libxml::xml::node#[]=()","libxml::xml::inputcallbacks::add_scheme()","libxml::xml::schema::type#annonymus_subtypes()","libxml::xml::schema::type#annonymus_subtypes_recursively()","libxml::xml::schema::element#annotation()","libxml::xml::schema::type#annotation()","libxml::xml::schema::element#array?()","libxml::xml::node#attribute?()","libxml::xml::reader#attribute_count()","libxml::xml::node#attribute_decl?()","libxml::xml::node#attributes()","libxml::xml::schema::type#attributes()","libxml::xml::node#attributes?()","libxml::xml::schema::type#base()","libxml::xml::node#base_uri()","libxml::xml::parser::context#base_uri()","libxml::xml::reader#base_uri()","libxml::xml::node#base_uri=()","libxml::xml::parser::context#base_uri=()","libxml::xml::node#blank?()","libxml::xml::reader#byte_consumed()","libxml::xml::document#canonicalize()","libxml::xml::catalog_dump()","libxml::xml::catalog_remove()","libxml::xml::node#cdata?()","libxml::xml::check_lib_versions()","libxml::xml::attr#child()","libxml::xml::attrdecl#child()","libxml::xml::document#child()","libxml::xml::node#child()","libxml::xml::attr#child?()","libxml::xml::attrdecl#child?()","libxml::xml::document#child?()","libxml::xml::node#child?()","libxml::xml::node#children()","libxml::xml::node#children?()","libxml::xml::node#clone()","libxml::xml::htmlparser::context#close()","libxml::xml::parser::context#close()","libxml::xml::reader#close()","libxml::xml::error#code_to_s()","libxml::xml::reader#column_number()","libxml::xml::node#comment?()","libxml::xml::xpath::expression::compile()","libxml::xml::document#compression()","libxml::xml::document#compression=()","libxml::xml::document#compression?()","libxml::xml::node#content()","libxml::xml::node#content=()","libxml::xml::document#context()","libxml::xml::node#context()","libxml::xml::node#copy()","libxml::xml::parser::context#data_directory()","libxml::xml::document#debug()","libxml::xml::node#debug()","libxml::xml::xpath::object#debug()","libxml::xml::namespaces#default()","libxml::xml::schema::attribute#default()","libxml::xml::reader#default?()","libxml::xml::default_compression()","libxml::xml::default_compression=()","libxml::xml::namespaces#default_prefix=()","libxml::xml::default_save_no_empty_tags()","libxml::xml::default_save_no_empty_tags=()","libxml::xml::default_tree_indent_string()","libxml::xml::default_tree_indent_string=()","libxml::xml::namespaces#definitions()","libxml::xml::parser::context#depth()","libxml::xml::reader#depth()","libxml::xml::xpath::context#disable_cache()","libxml::xml::htmlparser::context#disable_cdata=()","libxml::xml::parser::context#disable_cdata=()","libxml::xml::parser::context#disable_cdata?()","libxml::xml::parser::context#disable_sax?()","libxml::xml::attr#doc()","libxml::xml::attrdecl#doc()","libxml::xml::node#doc()","libxml::xml::reader#doc()","libxml::xml::xpath::context#doc()","libxml::xml::attr#doc?()","libxml::xml::attrdecl#doc?()","libxml::xml::parser::context#docbook?()","libxml::xml::node#docbook_doc?()","libxml::xml::node#doctype?()","libxml::xml::document::document()","libxml::xml::parser::document()","libxml::xml::parser::context::document()","libxml::xml::reader::document()","libxml::xml::relaxng::document()","libxml::xml::schema#document()","libxml::xml::schema::document()","libxml::xml::writer::document()","libxml::xml::node#document?()","libxml::xml::error#domain_to_s()","libxml::xml::node#dtd?()","libxml::xml::node#dup()","libxml::xml::attr#each()","libxml::xml::attributes#each()","libxml::xml::namespace#each()","libxml::xml::namespaces#each()","libxml::xml::node#each()","libxml::xml::xpath::object#each()","libxml::xml::attr#each_attr()","libxml::xml::node#each_attr()","libxml::xml::node#each_child()","libxml::xml::node#each_element()","libxml::xml::attr#each_sibling()","libxml::xml::node#element?()","libxml::xml::node#element_decl?()","libxml::xml::schema#elements()","libxml::xml::schema::element#elements()","libxml::xml::schema::type#elements()","libxml::xml::node#empty?()","libxml::xml::xpath::object#empty?()","libxml::xml::reader#empty_element?()","libxml::xml::xpath::context#enable_cache()","libxml::xml::enabled_automata?()","libxml::xml::enabled_c14n?()","libxml::xml::enabled_catalog?()","libxml::xml::enabled_debug?()","libxml::xml::enabled_docbook?()","libxml::xml::enabled_ftp?()","libxml::xml::enabled_html?()","libxml::xml::enabled_http?()","libxml::xml::enabled_iconv?()","libxml::xml::enabled_memory_debug?()","libxml::xml::enabled_regexp?()","libxml::xml::enabled_schemas?()","libxml::xml::enabled_thread?()","libxml::xml::enabled_unicode?()","libxml::xml::enabled_xinclude?()","libxml::xml::enabled_xpath?()","libxml::xml::enabled_xpointer?()","libxml::xml::enabled_zlib?()","libxml::xml::document#encoding()","libxml::xml::parser::context#encoding()","libxml::xml::reader#encoding()","libxml::xml::document#encoding=()","libxml::xml::parser::context#encoding=()","libxml::xml::writer#end_attribute()","libxml::xml::writer#end_cdata()","libxml::xml::writer#end_comment()","libxml::xml::writer#end_document()","libxml::xml::writer#end_dtd()","libxml::xml::writer#end_dtd_attlist()","libxml::xml::writer#end_dtd_element()","libxml::xml::writer#end_dtd_entity()","libxml::xml::writer#end_element()","libxml::xml::writer#end_pi()","libxml::xml::node#entity?()","libxml::xml::node#entity_ref?()","libxml::xml::error#eql?()","libxml::xml::node#eql?()","libxml::xml::parser::context#errno()","libxml::xml::reader#expand()","libxml::xml::dtd#external_id()","libxml::xml::schema::type#facets()","libxml::xml::document::file()","libxml::xml::htmlparser::file()","libxml::xml::htmlparser::context::file()","libxml::xml::parser::file()","libxml::xml::parser::context::file()","libxml::xml::reader::file()","libxml::xml::saxparser::file()","libxml::xml::writer::file()","libxml::xml::document#find()","libxml::xml::node#find()","libxml::xml::xpath::context#find()","libxml::xml::namespaces#find_by_href()","libxml::xml::namespaces#find_by_prefix()","libxml::xml::document#find_first()","libxml::xml::node#find_first()","libxml::xml::attributes#first()","libxml::xml::node#first()","libxml::xml::xpath::object#first()","libxml::xml::node#first?()","libxml::xml::writer#flush()","libxml::xml::node#fragment?()","libxml::xml::encoding::from_s()","libxml::xml::relaxng::from_string()","libxml::xml::schema::from_string()","libxml::xml::writer#full_end_element()","libxml::xml::attributes#get_attribute()","libxml::xml::reader#get_attribute()","libxml::xml::reader#get_attribute_no()","libxml::xml::attributes#get_attribute_ns()","libxml::xml::reader#get_attribute_ns()","libxml::xml::error::get_handler()","libxml::xml::reader#has_attributes?()","libxml::xml::reader#has_value?()","libxml::xml::namespace#href()","libxml::xml::parser::context#html?()","libxml::xml::node#html_doc?()","libxml::xml::document#import()","libxml::xml::schema#imported_ns_elements()","libxml::xml::schema#imported_ns_types()","libxml::xml::schema#imported_types()","libxml::xml::indent_tree_output()","libxml::xml::indent_tree_output=()","libxml::xml::node#inner_xml()","libxml::xml::document::io()","libxml::xml::htmlparser::io()","libxml::xml::htmlparser::context::io()","libxml::xml::parser::io()","libxml::xml::parser::context::io()","libxml::xml::reader::io()","libxml::xml::saxparser::io()","libxml::xml::writer::io()","libxml::xml::parser::context#io_max_num_streams()","libxml::xml::parser::context#io_num_streams()","libxml::xml::parser::context#keep_blanks?()","libxml::xml::schema::type#kind_name()","libxml::xml::node#lang()","libxml::xml::node#lang=()","libxml::xml::attr#last()","libxml::xml::document#last()","libxml::xml::node#last()","libxml::xml::xpath::object#last()","libxml::xml::attr#last?()","libxml::xml::document#last?()","libxml::xml::node#last?()","libxml::xml::attributes#length()","libxml::xml::xpath::object#length()","libxml::xml::error#level_to_s()","libxml::xml::node#line_num()","libxml::xml::reader#line_number()","libxml::xml::reader#local_name()","libxml::xml::reader#lookup_namespace()","libxml::xml::schema::element#max_occurs()","libxml::xml::memory_dump()","libxml::xml::memory_used()","libxml::xml::schema::element#min_occurs()","libxml::xml::reader#move_to_attribute()","libxml::xml::reader#move_to_attribute_no()","libxml::xml::reader#move_to_attribute_ns()","libxml::xml::reader#move_to_element()","libxml::xml::reader#move_to_first_attribute()","libxml::xml::reader#move_to_next_attribute()","libxml::xml::attr#name()","libxml::xml::attrdecl#name()","libxml::xml::dtd#name()","libxml::xml::node#name()","libxml::xml::reader#name()","libxml::xml::node#name=()","libxml::xml::parser::context#name_depth()","libxml::xml::parser::context#name_depth_max()","libxml::xml::parser::context#name_node()","libxml::xml::parser::context#name_tab()","libxml::xml::namespaces#namespace()","libxml::xml::namespaces#namespace=()","libxml::xml::node#namespace?()","libxml::xml::reader#namespace_declaration?()","libxml::xml::reader#namespace_uri()","libxml::xml::attr#namespaces()","libxml::xml::node#namespaces()","libxml::xml::schema#namespaces()","libxml::xml::attr::new()","libxml::xml::document::new()","libxml::xml::dtd::new()","libxml::xml::htmlparser::new()","libxml::xml::namespace::new()","libxml::xml::namespaces::new()","libxml::xml::node::new()","libxml::xml::parser::new()","libxml::xml::relaxng::new()","libxml::xml::saxparser::new()","libxml::xml::schema::new()","libxml::xml::xpath::context::new()","libxml::xml::xpath::expression::new()","libxml::xml::node::new_cdata()","libxml::xml::node::new_comment()","libxml::xml::node::new_pi()","libxml::xml::node::new_text()","libxml::xml::attr#next()","libxml::xml::attrdecl#next()","libxml::xml::document#next()","libxml::xml::namespace#next()","libxml::xml::node#next()","libxml::xml::reader#next()","libxml::xml::node#next=()","libxml::xml::attr#next?()","libxml::xml::attrdecl#next?()","libxml::xml::document#next?()","libxml::xml::node#next?()","libxml::xml::reader#next_sibling()","libxml::xml::attributes#node()","libxml::xml::namespaces#node()","libxml::xml::parser::context#node()","libxml::xml::reader#node()","libxml::xml::schema::attribute#node()","libxml::xml::schema::element#node()","libxml::xml::schema::facet#node()","libxml::xml::schema::type#node()","libxml::xml::xpath::context#node=()","libxml::xml::parser::context#node_depth()","libxml::xml::parser::context#node_depth_max()","libxml::xml::attr#node_type()","libxml::xml::attrdecl#node_type()","libxml::xml::document#node_type()","libxml::xml::dtd#node_type()","libxml::xml::namespace#node_type()","libxml::xml::node#node_type()","libxml::xml::reader#node_type()","libxml::xml::attr#node_type_name()","libxml::xml::attrdecl#node_type_name()","libxml::xml::document#node_type_name()","libxml::xml::node#node_type_name()","libxml::xml::reader#normalization()","libxml::xml::node#notation?()","libxml::xml::attr#ns()","libxml::xml::attr#ns?()","libxml::xml::parser::context#num_chars()","libxml::xml::saxparser::callbacks#on_cdata_block()","libxml::xml::saxparser::verbosecallbacks#on_cdata_block()","libxml::xml::saxparser::callbacks#on_characters()","libxml::xml::saxparser::verbosecallbacks#on_characters()","libxml::xml::saxparser::callbacks#on_comment()","libxml::xml::saxparser::verbosecallbacks#on_comment()","libxml::xml::saxparser::callbacks#on_end_document()","libxml::xml::saxparser::verbosecallbacks#on_end_document()","libxml::xml::saxparser::callbacks#on_end_element_ns()","libxml::xml::saxparser::verbosecallbacks#on_end_element_ns()","libxml::xml::saxparser::callbacks#on_error()","libxml::xml::saxparser::verbosecallbacks#on_error()","libxml::xml::saxparser::callbacks#on_external_subset()","libxml::xml::saxparser::verbosecallbacks#on_external_subset()","libxml::xml::saxparser::callbacks#on_has_external_subset()","libxml::xml::saxparser::verbosecallbacks#on_has_external_subset()","libxml::xml::saxparser::callbacks#on_has_internal_subset()","libxml::xml::saxparser::verbosecallbacks#on_has_internal_subset()","libxml::xml::saxparser::callbacks#on_internal_subset()","libxml::xml::saxparser::verbosecallbacks#on_internal_subset()","libxml::xml::saxparser::callbacks#on_is_standalone()","libxml::xml::saxparser::verbosecallbacks#on_is_standalone()","libxml::xml::saxparser::callbacks#on_processing_instruction()","libxml::xml::saxparser::verbosecallbacks#on_processing_instruction()","libxml::xml::saxparser::callbacks#on_reference()","libxml::xml::saxparser::verbosecallbacks#on_reference()","libxml::xml::saxparser::callbacks#on_start_document()","libxml::xml::saxparser::verbosecallbacks#on_start_document()","libxml::xml::saxparser::callbacks#on_start_element_ns()","libxml::xml::saxparser::verbosecallbacks#on_start_element_ns()","libxml::xml::parser::context#options()","libxml::xml::htmlparser::context#options=()","libxml::xml::parser::context#options=()","libxml::xml::document#order_elements!()","libxml::xml::node#output_escaping=()","libxml::xml::node#output_escaping?()","libxml::xml::attr#parent()","libxml::xml::attrdecl#parent()","libxml::xml::document#parent()","libxml::xml::node#parent()","libxml::xml::attr#parent?()","libxml::xml::attrdecl#parent?()","libxml::xml::document#parent?()","libxml::xml::node#parent?()","libxml::xml::htmlparser#parse()","libxml::xml::parser#parse()","libxml::xml::saxparser#parse()","libxml::xml::node#path()","libxml::xml::node#pi?()","libxml::xml::namespace#prefix()","libxml::xml::reader#prefix()","libxml::xml::attr#prev()","libxml::xml::attrdecl#prev()","libxml::xml::document#prev()","libxml::xml::node#prev()","libxml::xml::node#prev=()","libxml::xml::attr#prev?()","libxml::xml::attrdecl#prev?()","libxml::xml::document#prev?()","libxml::xml::node#prev?()","libxml::xml::reader#quote_char()","libxml::xml::document#rb_encoding()","libxml::xml::reader#read()","libxml::xml::reader#read_attribute_value()","libxml::xml::reader#read_inner_xml()","libxml::xml::reader#read_outer_xml()","libxml::xml::reader#read_state()","libxml::xml::reader#read_string()","libxml::xml::parser::context#recovery=()","libxml::xml::parser::context#recovery?()","libxml::xml::inputcallbacks::register()","libxml::xml::parser::register_error_handler()","libxml::xml::xpath::context#register_namespace()","libxml::xml::xpath::context#register_namespaces()","libxml::xml::xpath::context#register_namespaces_from_node()","libxml::xml::reader#relax_ng_validate()","libxml::xml::attr#remove!()","libxml::xml::node#remove!()","libxml::xml::inputcallbacks::remove_scheme()","libxml::xml::parser::context#replace_entities=()","libxml::xml::parser::context#replace_entities?()","libxml::xml::schema::attribute#required?()","libxml::xml::schema::element#required?()","libxml::xml::error::reset_handler()","libxml::xml::writer#result()","libxml::xml::document#root()","libxml::xml::document#root=()","libxml::xml::document#save()","libxml::xml::reader#schema_validate()","libxml::xml::error::set_handler()","libxml::xml::writer#set_indent()","libxml::xml::writer#set_indent_string()","libxml::xml::writer#set_quote_char()","libxml::xml::node#sibling=()","libxml::xml::attr#siblings()","libxml::xml::xpath::object#size()","libxml::xml::parser::context#space_depth()","libxml::xml::parser::context#space_depth_max()","libxml::xml::node#space_preserve()","libxml::xml::node#space_preserve=()","libxml::xml::reader#standalone()","libxml::xml::document#standalone?()","libxml::xml::parser::context#standalone?()","libxml::xml::writer#start_attribute()","libxml::xml::writer#start_attribute_ns()","libxml::xml::writer#start_cdata()","libxml::xml::writer#start_comment()","libxml::xml::writer#start_document()","libxml::xml::writer#start_dtd()","libxml::xml::writer#start_dtd_attlist()","libxml::xml::writer#start_dtd_element()","libxml::xml::writer#start_dtd_entity()","libxml::xml::writer#start_element()","libxml::xml::writer#start_element_ns()","libxml::xml::writer#start_pi()","libxml::xml::parser::context#stats?()","libxml::xml::document::string()","libxml::xml::htmlparser::string()","libxml::xml::htmlparser::context::string()","libxml::xml::parser::string()","libxml::xml::parser::context::string()","libxml::xml::reader::string()","libxml::xml::saxparser::string()","libxml::xml::writer::string()","libxml::xml::xpath::object#string()","libxml::xml::parser::context#subset_external?()","libxml::xml::parser::context#subset_external_system_id()","libxml::xml::parser::context#subset_external_uri()","libxml::xml::parser::context#subset_internal?()","libxml::xml::parser::context#subset_internal_name()","libxml::xml::dtd#system_id()","libxml::xml::node#text?()","libxml::xml::attr#to_a()","libxml::xml::xpath::object#to_a()","libxml::xml::attr#to_h()","libxml::xml::attributes#to_h()","libxml::xml::encoding::to_rb_encoding()","libxml::xml::attr#to_s()","libxml::xml::attrdecl#to_s()","libxml::xml::document#to_s()","libxml::xml::encoding::to_s()","libxml::xml::error#to_s()","libxml::xml::namespace#to_s()","libxml::xml::node#to_s()","libxml::xml::schema#types()","libxml::xml::dtd#uri()","libxml::xml::document#url()","libxml::xml::parser::context#valid()","libxml::xml::reader#valid?()","libxml::xml::document#validate()","libxml::xml::parser::context#validate?()","libxml::xml::document#validate_relaxng()","libxml::xml::document#validate_schema()","libxml::xml::attr#value()","libxml::xml::attrdecl#value()","libxml::xml::reader#value()","libxml::xml::attr#value=()","libxml::xml::document#version()","libxml::xml::parser::context#version()","libxml::xml::parser::context#well_formed?()","libxml::xml::writer#write_attribute()","libxml::xml::writer#write_attribute_ns()","libxml::xml::writer#write_cdata()","libxml::xml::writer#write_comment()","libxml::xml::writer#write_dtd()","libxml::xml::writer#write_dtd_attlist()","libxml::xml::writer#write_dtd_element()","libxml::xml::writer#write_dtd_entity()","libxml::xml::writer#write_dtd_external_entity()","libxml::xml::writer#write_dtd_external_entity_contents()","libxml::xml::writer#write_dtd_internal_entity()","libxml::xml::writer#write_dtd_notation()","libxml::xml::writer#write_element()","libxml::xml::writer#write_element_ns()","libxml::xml::writer#write_pi()","libxml::xml::writer#write_raw()","libxml::xml::writer#write_string()","libxml::xml::document#xhtml?()","libxml::xml::document#xinclude()","libxml::xml::node#xinclude_end?()","libxml::xml::node#xinclude_start?()","libxml::xml::node#xlink?()","libxml::xml::node#xlink_type()","libxml::xml::node#xlink_type_name()","libxml::xml::reader#xml_lang()","libxml::xml::reader#xml_version()","libxml::xml::xpath::object#xpath_type()","","",""],"info":[["Float","","Float.html","",""],["LibXML","","LibXML.html","",""],["LibXML::XML","","LibXML/XML.html","",""],["LibXML::XML::Attr","","LibXML/XML/Attr.html","","<p>Provides access to an attribute defined on an element.\n<p>Basic Usage:\n\n<pre>require &#39;test_helper&#39;\n\ndoc = XML::Document.new(&lt;some_file&gt;) ...</pre>\n"],["LibXML::XML::AttrDecl","","LibXML/XML/AttrDecl.html","","<p>At attribute declaration is used in XML::Dtds to define what attributes are allowed on an element.   …\n"],["LibXML::XML::Attributes","","LibXML/XML/Attributes.html","","<p>Provides access to an element’s attributes (XML::Attr).\n<p>Basic Usage:\n\n<pre>require &#39;test_helper&#39;\n\ndoc = XML::Document.new(&lt;some_file&gt;) ...</pre>\n"],["LibXML::XML::Document","","LibXML/XML/Document.html","","<p>The XML::Document class provides a tree based API for working with xml documents.  You may directly create …\n"],["LibXML::XML::Dtd","","LibXML/XML/Dtd.html","","<p>The XML::Dtd class is used to prepare DTD’s for validation of xml documents.\n<p>DTDs can be created from …\n"],["LibXML::XML::Encoding","","LibXML/XML/Encoding.html","","<p>The encoding class exposes the encodings that libxml supports via constants.\n<p>LibXML converts all data …\n"],["LibXML::XML::Error","","LibXML/XML/Error.html","","<p>The XML::Error class exposes libxml errors as standard Ruby exceptions.  When appropriate, libxml-ruby …\n"],["LibXML::XML::HTMLParser","","LibXML/XML/HTMLParser.html","","<p>The HTML parser implements an HTML 4.0 non-verifying parser with an API compatible with the XML::Parser …\n"],["LibXML::XML::HTMLParser::Context","","LibXML/XML/HTMLParser/Context.html","","<p>The XML::HTMLParser::Context class provides in-depth control over how a document is parsed.\n"],["LibXML::XML::HTMLParser::Options","","LibXML/XML/HTMLParser/Options.html","","<p>Options to control the operation of the HTMLParser.  The easiest way to set a parser’s options is …\n"],["LibXML::XML::InputCallbacks","","LibXML/XML/InputCallbacks.html","","<p>Support for adding custom scheme handlers.\n"],["LibXML::XML::Namespace","","LibXML/XML/Namespace.html","","<p>The Namespace class represents an XML namespace. To add a namespace to a node, create a new instance …\n"],["LibXML::XML::Namespaces","","LibXML/XML/Namespaces.html","","<p>The XML::Namespaces class is used to access information about a node’s namespaces.  For each node, …\n"],["LibXML::XML::Node","","LibXML/XML/Node.html","","<p>Nodes are the primary objects that make up an XML document. The node class represents most node types …\n"],["LibXML::XML::Parser","","LibXML/XML/Parser.html","","<p>The XML::Parser provides a tree based API for processing xml documents, in contract to XML::Reader’s …\n"],["LibXML::XML::Parser::Context","","LibXML/XML/Parser/Context.html","","<p>The XML::Parser::Context class provides in-depth control over how a document is parsed.\n"],["LibXML::XML::Parser::Options","","LibXML/XML/Parser/Options.html","","<p>Options that control the operation of the HTMLParser.  The easiest way to set a parser’s options …\n"],["LibXML::XML::Reader","","LibXML/XML/Reader.html","","<p>The XML::Reader class provides a simpler, alternative way of parsing an XML document in contrast to  …\n"],["LibXML::XML::RelaxNG","","LibXML/XML/RelaxNG.html","","<p>The XML::RelaxNG class is used to prepare RelaxNG schemas for validation of xml documents.\n<p>Schemas can …\n"],["LibXML::XML::SaxParser","","LibXML/XML/SaxParser.html","","<p>XML::SaxParser provides a callback based API for parsing documents, in contrast to XML::Parser’s …\n"],["LibXML::XML::SaxParser::Callbacks","","LibXML/XML/SaxParser/Callbacks.html","",""],["LibXML::XML::SaxParser::VerboseCallbacks","","LibXML/XML/SaxParser/VerboseCallbacks.html","",""],["LibXML::XML::Schema","","LibXML/XML/Schema.html","","<p>The XML::Schema class is used to prepare XML Schemas for validation of xml documents.\n<p>Schemas can be created …\n"],["LibXML::XML::Schema::Attribute","","LibXML/XML/Schema/Attribute.html","",""],["LibXML::XML::Schema::Element","","LibXML/XML/Schema/Element.html","",""],["LibXML::XML::Schema::Facet","","LibXML/XML/Schema/Facet.html","",""],["LibXML::XML::Schema::Type","","LibXML/XML/Schema/Type.html","",""],["LibXML::XML::Schema::Types","","LibXML/XML/Schema/Types.html","",""],["LibXML::XML::Writer","","LibXML/XML/Writer.html","","<p>The XML::Writer class provides a simpler, alternative way to build a valid XML document from scratch …\n"],["LibXML::XML::XInclude","","LibXML/XML/XInclude.html","","<p>The ruby bindings do not currently expose libxml’s XInclude fuctionality.\n"],["LibXML::XML::XPath","","LibXML/XML/XPath.html","","<p>The XML::XPath module is used to query XML documents. It is usually accessed via the XML::Document#find …\n"],["LibXML::XML::XPath::Context","","LibXML/XML/XPath/Context.html","","<p>The XML::XPath::Context class is used to evaluate XPath expressions.  Generally, you should not directly …\n"],["LibXML::XML::XPath::Expression","","LibXML/XML/XPath/Expression.html","","<p>The XML::XPath::Expression class is used to compile XPath expressions so they can be parsed only once …\n"],["LibXML::XML::XPath::Object","","LibXML/XML/XPath/Object.html","","<p>A collection of nodes returned from the evaluation of an XML::XPath or XML::XPointer expression.\n"],["Object","","Object.html","",""],["<<","LibXML::XML::Node","LibXML/XML/Node.html#method-i-3C-3C","(p1)","<p>Add  the specified text or XML::Node as a new child node to the current node.\n<p>If the specified argument …\n"],["<=>","LibXML::XML::Namespace","LibXML/XML/Namespace.html#method-i-3C-3D-3E","(other)","<p>Compares two namespace objects.  Namespace objects are considered equal if their prefixes and hrefs are …\n"],["==","LibXML::XML::Error","LibXML/XML/Error.html#method-i-3D-3D","(other)",""],["==","LibXML::XML::Node","LibXML/XML/Node.html#method-i-3D-3D","(p1)","<p>Test equality between the two nodes. Two nodes are equal if they are the same node.\n"],["[]","LibXML::XML::Attributes","LibXML/XML/Attributes.html#method-i-5B-5D","(p1)","<p>Fetches an attribute value. If you want to access the underlying Attribute itself use get_attribute. …\n"],["[]","LibXML::XML::Node","LibXML/XML/Node.html#method-i-5B-5D","(p1)","<p>Obtain the named property.\n"],["[]","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-5B-5D","(p1)","<p>Provide the value of the attribute with the specified index (if <code>key</code> is an integer) or with the specified …\n"],["[]","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-5B-5D","(p1)","<p>array index into set of nodes\n"],["[]=","LibXML::XML::Attributes","LibXML/XML/Attributes.html#method-i-5B-5D-3D","(p1, p2)","<p>Sets an attribute value. If you want to get the Attribute itself, use get_attribute.\n<p>name: The name of …\n"],["[]=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-5B-5D-3D","(p1, p2)","<p>Set the named property.\n"],["add_scheme","LibXML::XML::InputCallbacks","LibXML/XML/InputCallbacks.html#method-c-add_scheme","(p1, p2)","<p>No documentation available.\n"],["annonymus_subtypes","LibXML::XML::Schema::Type","LibXML/XML/Schema/Type.html#method-i-annonymus_subtypes","()",""],["annonymus_subtypes_recursively","LibXML::XML::Schema::Type","LibXML/XML/Schema/Type.html#method-i-annonymus_subtypes_recursively","(parent=nil)",""],["annotation","LibXML::XML::Schema::Element","LibXML/XML/Schema/Element.html#method-i-annotation","()",""],["annotation","LibXML::XML::Schema::Type","LibXML/XML/Schema/Type.html#method-i-annotation","()",""],["array?","LibXML::XML::Schema::Element","LibXML/XML/Schema/Element.html#method-i-array-3F","()",""],["attribute?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-attribute-3F","()","<p>Specifies if this is an attribute node\n"],["attribute_count","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-attribute_count","()","<p>Provide the number of attributes of the current node.\n"],["attribute_decl?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-attribute_decl-3F","()","<p>Specifies if this is an attribute declaration node\n"],["attributes","LibXML::XML::Node","LibXML/XML/Node.html#method-i-attributes","()","<p>Returns the XML::Attributes for this node.\n"],["attributes","LibXML::XML::Schema::Type","LibXML/XML/Schema/Type.html#method-i-attributes","()",""],["attributes?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-attributes-3F","()","<p>Determines whether this node has attributes\n"],["base","LibXML::XML::Schema::Type","LibXML/XML/Schema/Type.html#method-i-base","()",""],["base_uri","LibXML::XML::Node","LibXML/XML/Node.html#method-i-base_uri","()","<p>Obtain this node’s base URI.\n"],["base_uri","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-base_uri","()","<p>Obtain the base url for this parser context.\n"],["base_uri","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-base_uri","()","<p>Determine the base URI of the node.\n"],["base_uri=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-base_uri-3D","(p1)","<p>Set this node’s base URI.\n"],["base_uri=","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-base_uri-3D","(p1)","<p>Sets the base url for this parser context.\n"],["blank?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-blank-3F","()","<p>Determine whether this node is an empty or whitespace only text-node.\n"],["byte_consumed","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-byte_consumed","()","<p>This method provides the current index of the parser used by the reader, relative to the start of the …\n"],["canonicalize","LibXML::XML::Document","LibXML/XML/Document.html#method-i-canonicalize","(p1 = v1)",""],["catalog_dump","LibXML::XML","LibXML/XML.html#method-c-catalog_dump","()","<p>Dump all the global catalog content stdout.\n"],["catalog_remove","LibXML::XML","LibXML/XML.html#method-c-catalog_remove","(p1)","<p>Remove the specified resource catalog.\n"],["cdata?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-cdata-3F","()","<p>Specifies if this is an CDATA node\n"],["check_lib_versions","LibXML::XML","LibXML/XML.html#method-c-check_lib_versions","()","<p>Check LIBXML version matches version the bindings were compiled to. Throws an exception if not.\n"],["child","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-child","()","<p>Obtain this attribute’s child attribute(s).\n"],["child","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-child","()","<p>Obtain this attribute declaration’s child attribute(s). It will always be nil.\n"],["child","LibXML::XML::Document","LibXML/XML/Document.html#method-i-child","()","<p>Get this document’s child node.\n"],["child","LibXML::XML::Node","LibXML/XML/Node.html#method-i-child","()",""],["child?","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-child-3F","()","<p>Returns whether this attribute has child attributes.\n"],["child?","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-child-3F","()","<p>Returns whether this attribute declaration has child attributes.\n"],["child?","LibXML::XML::Document","LibXML/XML/Document.html#method-i-child-3F","()","<p>Determine whether this document has a child node.\n"],["child?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-child-3F","()",""],["children","LibXML::XML::Node","LibXML/XML/Node.html#method-i-children","()","<p>Returns this node’s children as an array.\n"],["children?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-children-3F","()",""],["clone","LibXML::XML::Node","LibXML/XML/Node.html#method-i-clone","()","<p>Create a shallow copy of the node.  To create a deep copy call Node#copy(true)\n"],["close","LibXML::XML::HTMLParser::Context","LibXML/XML/HTMLParser/Context.html#method-i-close","()","<p>Closes the underlying input streams.  This is useful when parsing a large amount of files and you want …\n"],["close","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-close","()","<p>Closes the underlying input streams.  This is useful when parsing a large amount of files and you want …\n"],["close","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-close","()","<p>This method releases any resources allocated by the current instance changes the state to Closed and …\n"],["code_to_s","LibXML::XML::Error","LibXML/XML/Error.html#method-i-code_to_s","()",""],["column_number","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-column_number","()","<p>Provide the column number of the current parsing point.\n"],["comment?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-comment-3F","()","<p>Specifies if this is an comment node\n"],["compile","LibXML::XML::XPath::Expression","LibXML/XML/XPath/Expression.html#method-c-compile","(p1)","<p>Compiles an XPath expression. This improves performance when an XPath expression is called multiple times. …\n"],["compression","LibXML::XML::Document","LibXML/XML/Document.html#method-i-compression","()","<p>Obtain this document’s compression mode identifier.\n"],["compression=","LibXML::XML::Document","LibXML/XML/Document.html#method-i-compression-3D","(p1)","<p>Set this document’s compression mode.\n"],["compression?","LibXML::XML::Document","LibXML/XML/Document.html#method-i-compression-3F","()","<p>Determine whether this document is compressed.\n"],["content","LibXML::XML::Node","LibXML/XML/Node.html#method-i-content","()","<p>Obtain this node’s content as a string.\n"],["content=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-content-3D","(p1)","<p>Set this node’s content to the specified string.\n"],["context","LibXML::XML::Document","LibXML/XML/Document.html#method-i-context","(nslist = nil)","<p>Returns a new XML::XPathContext for the document.\n<p>Namespaces is an optional array of XML::NS objects\n"],["context","LibXML::XML::Node","LibXML/XML/Node.html#method-i-context","(nslist = nil)","<p>Returns a new XML::XPathContext for the current node.\n<p>Namespaces is an optional array of XML::NS objects …\n"],["copy","LibXML::XML::Node","LibXML/XML/Node.html#method-i-copy","(p1)","<p>Creates a copy of this node.  To create a shallow copy set the deep parameter to false. To create a deep …\n"],["data_directory","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-data_directory","()","<p>Obtain the data directory associated with this context.\n"],["debug","LibXML::XML::Document","LibXML/XML/Document.html#method-i-debug","()","<p>Print libxml debugging information to stdout. Requires that libxml was compiled with debugging enabled. …\n"],["debug","LibXML::XML::Node","LibXML/XML/Node.html#method-i-debug","()","<p>Print libxml debugging information to stdout. Requires that libxml was compiled with debugging enabled. …\n"],["debug","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-debug","()","<p>Dump libxml debugging information to stdout. Requires Libxml be compiled with debugging enabled.\n"],["default","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-i-default","()","<p>Returns the default namespace for this node or nil.\n<p>Usage:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">string</span>(<span class=\"ruby-string\">&#39;&lt;Envelope xmlns=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;/&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["default","LibXML::XML::Schema::Attribute","LibXML/XML/Schema/Attribute.html#method-i-default","()",""],["default?","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-default-3F","()","<p>Return whether an Attribute node was generated from the default value defined in the DTD or schema.\n"],["default_compression","LibXML::XML","LibXML/XML.html#method-c-default_compression","()","<p>Determine whether parsers use Zlib compression by default (requires libxml to be compiled with Zlib support). …\n"],["default_compression=","LibXML::XML","LibXML/XML.html#method-c-default_compression-3D","(p1)","<p>Controls whether parsers use Zlib compression by default (requires libxml to be compiled with Zlib support). …\n"],["default_prefix=","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-i-default_prefix-3D","(prefix)","<p>Assigns a name (prefix) to the default namespace. This makes it much easier to perform XML::XPath searches. …\n"],["default_save_no_empty_tags","LibXML::XML","LibXML/XML.html#method-c-default_save_no_empty_tags","()","<p>Determine whether serializer outputs empty tags by default.\n"],["default_save_no_empty_tags=","LibXML::XML","LibXML/XML.html#method-c-default_save_no_empty_tags-3D","(p1)","<p>Controls whether serializer outputs empty tags by default.\n"],["default_tree_indent_string","LibXML::XML","LibXML/XML.html#method-c-default_tree_indent_string","()","<p>Obtain the default string used by parsers to indent the XML tree for output.\n"],["default_tree_indent_string=","LibXML::XML","LibXML/XML.html#method-c-default_tree_indent_string-3D","(p1)","<p>Set the default string used by parsers to indent the XML tree for output.\n"],["definitions","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-i-definitions","()","<p>Returns an array of XML::Namespace objects that are defined on this node.\n<p>Usage:\n\n<pre>doc = XML::Document.string(&#39;&lt;soap:Envelope ...</pre>\n"],["depth","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-depth","()","<p>Obtain the depth of this context.\n"],["depth","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-depth","()","<p>Get the depth of the node in the tree.\n"],["disable_cache","LibXML::XML::XPath::Context","LibXML/XML/XPath/Context.html#method-i-disable_cache","()","<p>Disables an XPath::Context’s built-in cache.\n"],["disable_cdata=","LibXML::XML::HTMLParser::Context","LibXML/XML/HTMLParser/Context.html#method-i-disable_cdata-3D","(p1)","<p>Control whether the CDATA nodes will be created in this context.\n"],["disable_cdata=","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-disable_cdata-3D","(p1)","<p>Control whether CDATA nodes will be created in this context.\n"],["disable_cdata?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-disable_cdata-3F","()","<p>Determine whether CDATA nodes will be created in this context.\n"],["disable_sax?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-disable_sax-3F","()","<p>Determine whether SAX-based processing is disabled in this context.\n"],["doc","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-doc","()","<p>Returns this attribute’s document.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span>.<span class=\"ruby-identifier\">root</span>.<span class=\"ruby-identifier\">attributes</span>.<span class=\"ruby-identifier\">get_attribute</span>(<span class=\"ruby-string\">&#39;name&#39;</span>).<span class=\"ruby-identifier\">doc</span> <span class=\"ruby-operator\">==</span> <span class=\"ruby-identifier\">doc</span>\n</pre>\n"],["doc","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-doc","()","<p>Returns this attribute declaration’s document.\n"],["doc","LibXML::XML::Node","LibXML/XML/Node.html#method-i-doc","()","<p>Obtain the XML::Document this node belongs to.\n"],["doc","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-doc","()","<p>Hacking interface that provides access to the current document being accessed by the reader. NOTE: as …\n"],["doc","LibXML::XML::XPath::Context","LibXML/XML/XPath/Context.html#method-i-doc","()","<p>Obtain the XML::Document this node belongs to.\n"],["doc?","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-doc-3F","()","<p>Determine whether this attribute is associated with an XML::Document.\n"],["doc?","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-doc-3F","()","<p>Determine whether this attribute declaration is associated with an XML::Document.\n"],["docbook?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-docbook-3F","()","<p>Determine whether this is a docbook context.\n"],["docbook_doc?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-docbook_doc-3F","()","<p>Specifies if this is an docbook node\n"],["doctype?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-doctype-3F","()","<p>Specifies if this is an doctype node\n"],["document","LibXML::XML::Document","LibXML/XML/Document.html#method-c-document","(value)","<p>Creates a new document based on the specified document.\n<p>Parameters:\n\n<pre>document - A preparsed document.</pre>\n"],["document","LibXML::XML::Parser","LibXML/XML/Parser.html#method-c-document","(doc)","<p>Creates a new parser for the specified document.\n<p>Parameters:\n\n<pre>document - A preparsed document.</pre>\n"],["document","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-c-document","(p1, p2 = v2)","<p>Creates a new parser context based on the specified document.\n<p>Parameters:\n\n<pre>document - An XML::Document instance ...</pre>\n"],["document","LibXML::XML::Reader","LibXML/XML/Reader.html#method-c-document","(p1)","<p>Create an new reader for the specified document.\n"],["document","LibXML::XML::RelaxNG","LibXML/XML/RelaxNG.html#method-c-document","(p1)","<p>Create a new relaxng from the specified document.\n"],["document","LibXML::XML::Schema","LibXML/XML/Schema.html#method-i-document","()","<p>Return the Schema XML Document\n"],["document","LibXML::XML::Schema","LibXML/XML/Schema.html#method-c-document","(p1)","<p>Create a new schema from the specified document.\n"],["document","LibXML::XML::Writer","LibXML/XML/Writer.html#method-c-document","()","<p>Creates a XML::Writer which will write into an in memory XML::Document\n"],["document?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-document-3F","()","<p>Specifies if this is an document node\n"],["domain_to_s","LibXML::XML::Error","LibXML/XML/Error.html#method-i-domain_to_s","()",""],["dtd?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-dtd-3F","()","<p>Specifies if this is an DTD node\n"],["dup","LibXML::XML::Node","LibXML/XML/Node.html#method-i-dup","()","<p>Create a shallow copy of the node.  To create a deep copy call Node#copy(true)\n"],["each","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-each","(&blk)",""],["each","LibXML::XML::Attributes","LibXML/XML/Attributes.html#method-i-each","()","<p>Iterates over each attribute.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span>.<span class=\"ruby-identifier\">root</span>.<span class=\"ruby-identifier\">attributes</span>.<span class=\"ruby-identifier\">each</span> {<span class=\"ruby-operator\">|</span><span class=\"ruby-identifier\">attribute</span><span class=\"ruby-operator\">|</span> <span class=\"ruby-identifier\">puts</span> <span class=\"ruby-identifier\">attribute</span>.<span class=\"ruby-identifier\">name</span>}\n</pre>\n"],["each","LibXML::XML::Namespace","LibXML/XML/Namespace.html#method-i-each","()","<p>libxml stores namespaces in memory as a linked list. Use the each method to iterate over the list.   …\n"],["each","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-i-each","()","<p>Iterates over the namespace objects that are in context for this node.\n<p>Usage:\n\n<pre>doc = XML::Document.string(&#39;&lt;soap:Envelope ...</pre>\n"],["each","LibXML::XML::Node","LibXML/XML/Node.html#method-i-each","()","<p>Iterates over this node’s children, including text nodes, element nodes, etc.  If you wish to iterate …\n"],["each","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-each","()","<p>Call the supplied block for each node in this set.\n"],["each_attr","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-each_attr","(&blk)",""],["each_attr","LibXML::XML::Node","LibXML/XML/Node.html#method-i-each_attr","()","<p>——-  Traversal  —————- Iterates over this node’s attributes.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;model/books.xml&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["each_child","LibXML::XML::Node","LibXML/XML/Node.html#method-i-each_child","()",""],["each_element","LibXML::XML::Node","LibXML/XML/Node.html#method-i-each_element","()","<p>Iterates over this node’s child elements (nodes that have a node_type == ELEMENT_NODE).\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;model/books.xml&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["each_sibling","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-each_sibling","(&blk)",""],["element?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-element-3F","()","<p>Specifies if this is an element node\n"],["element_decl?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-element_decl-3F","()","<p>Specifies if this is an element declaration node\n"],["elements","LibXML::XML::Schema","LibXML/XML/Schema.html#method-i-elements","()",""],["elements","LibXML::XML::Schema::Element","LibXML/XML/Schema/Element.html#method-i-elements","()",""],["elements","LibXML::XML::Schema::Type","LibXML/XML/Schema/Type.html#method-i-elements","()",""],["empty?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-empty-3F","()","<p>Determine whether this node is an empty or whitespace only text-node.\n"],["empty?","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-empty-3F","()","<p>Determine whether this nodeset is empty (contains no nodes).\n"],["empty_element?","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-empty_element-3F","()","<p>Check if the current node is empty.\n"],["enable_cache","LibXML::XML::XPath::Context","LibXML/XML/XPath/Context.html#method-i-enable_cache","(p1 = v1)","<p>Enables an XPath::Context’s built-in cache.  If the cache is enabled then XPath objects will be cached …\n"],["enabled_automata?","LibXML::XML","LibXML/XML.html#method-c-enabled_automata-3F","()","<p>Determine whether libxml regexp automata support is enabled.\n"],["enabled_c14n?","LibXML::XML","LibXML/XML.html#method-c-enabled_c14n-3F","()","<p>Determine whether libxml ‘canonical XML’ support is enabled. See “Canonical XML” ( …\n"],["enabled_catalog?","LibXML::XML","LibXML/XML.html#method-c-enabled_catalog-3F","()","<p>Determine whether libxml resource catalog support is enabled.\n"],["enabled_debug?","LibXML::XML","LibXML/XML.html#method-c-enabled_debug-3F","()","<p>Determine whether libxml debugging support is enabled.\n"],["enabled_docbook?","LibXML::XML","LibXML/XML.html#method-c-enabled_docbook-3F","()","<p>Determine whether libxml docbook support is enabled.\n"],["enabled_ftp?","LibXML::XML","LibXML/XML.html#method-c-enabled_ftp-3F","()","<p>Determine whether libxml ftp client support is enabled.\n"],["enabled_html?","LibXML::XML","LibXML/XML.html#method-c-enabled_html-3F","()","<p>Determine whether libxml html support is enabled.\n"],["enabled_http?","LibXML::XML","LibXML/XML.html#method-c-enabled_http-3F","()","<p>Determine whether libxml http client support is enabled.\n"],["enabled_iconv?","LibXML::XML","LibXML/XML.html#method-c-enabled_iconv-3F","()","<p>Determine whether libxml iconv support is enabled.\n"],["enabled_memory_debug?","LibXML::XML","LibXML/XML.html#method-c-enabled_memory_debug-3F","()","<p>Determine whether libxml memory location debugging support is enabled.\n"],["enabled_regexp?","LibXML::XML","LibXML/XML.html#method-c-enabled_regexp-3F","()","<p>Determine whether libxml regular expression support is enabled.\n"],["enabled_schemas?","LibXML::XML","LibXML/XML.html#method-c-enabled_schemas-3F","()","<p>Determine whether libxml schema support is enabled.\n"],["enabled_thread?","LibXML::XML","LibXML/XML.html#method-c-enabled_thread-3F","()","<p>Determine whether thread-safe semantics support for libxml is enabled and is used by this ruby extension. …\n"],["enabled_unicode?","LibXML::XML","LibXML/XML.html#method-c-enabled_unicode-3F","()","<p>Determine whether libxml unicode support is enabled.\n"],["enabled_xinclude?","LibXML::XML","LibXML/XML.html#method-c-enabled_xinclude-3F","()","<p>Determine whether libxml xinclude support is enabled.\n"],["enabled_xpath?","LibXML::XML","LibXML/XML.html#method-c-enabled_xpath-3F","()","<p>Determine whether libxml xpath support is enabled.\n"],["enabled_xpointer?","LibXML::XML","LibXML/XML.html#method-c-enabled_xpointer-3F","()","<p>Determine whether libxml xpointer support is enabled.\n"],["enabled_zlib?","LibXML::XML","LibXML/XML.html#method-c-enabled_zlib-3F","()","<p>Determine whether libxml zlib support is enabled.\n"],["encoding","LibXML::XML::Document","LibXML/XML/Document.html#method-i-encoding","()","<p>Returns the LibXML encoding constant specified by this document.\n"],["encoding","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-encoding","()","<p>Obtain the character encoding identifier used in this context.\n"],["encoding","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-encoding","()","<p>Returns the encoding of the document being read.  Note you first have to read data from the reader for …\n"],["encoding=","LibXML::XML::Document","LibXML/XML/Document.html#method-i-encoding-3D","(p1)","<p>Set the encoding for this document.\n"],["encoding=","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-encoding-3D","(p1)","<p>Sets the character encoding for this context.\n"],["end_attribute","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_attribute","()","<p>Ends an attribute, namespaced or not. Returns <code>false</code> on failure.\n"],["end_cdata","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_cdata","()","<p>Ends current CDATA section. Returns <code>false</code> on failure.\n"],["end_comment","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_comment","()","<p>Ends current comment, returns <code>false</code> on failure. Note: libxml2 &gt;= 2.6.7 required\n"],["end_document","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_document","()","<p>Ends current document. Returns <code>false</code> on failure.\n"],["end_dtd","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_dtd","()","<p>Ends current DTD, returns <code>false</code> on failure.\n"],["end_dtd_attlist","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_dtd_attlist","()","<p>Ends current DTD attribute list, returns <code>false</code> on failure.\n"],["end_dtd_element","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_dtd_element","()","<p>Ends current DTD element, returns <code>false</code> on failure.\n"],["end_dtd_entity","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_dtd_entity","()","<p>Ends current DTD entity, returns <code>false</code> on failure.\n"],["end_element","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_element","()","<p>Ends current element, namespaced or not. Returns <code>false</code> on failure.\n"],["end_pi","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-end_pi","()","<p>Ends current processing instruction. Returns <code>false</code> on failure.\n"],["entity?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-entity-3F","()","<p>Specifies if this is an entity node\n"],["entity_ref?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-entity_ref-3F","()","<p>Specifies if this is an entity reference node\n"],["eql?","LibXML::XML::Error","LibXML/XML/Error.html#method-i-eql-3F","(other)",""],["eql?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-eql-3F","(p1)","<p>Test equality between the two nodes. Two nodes are equal if they are the same node.\n"],["errno","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-errno","()","<p>Obtain the last-error number in this context.\n"],["expand","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-expand","()","<p>Returns the current node and its full subtree. Note the returned node is valid ONLY until the next read …\n"],["external_id","LibXML::XML::Dtd","LibXML/XML/Dtd.html#method-i-external_id","()","<p>Obtain this dtd’s external identifer (for a PUBLIC DTD).\n"],["facets","LibXML::XML::Schema::Type","LibXML/XML/Schema/Type.html#method-i-facets","()",""],["file","LibXML::XML::Document","LibXML/XML/Document.html#method-c-file","(path, encoding: nil, options: nil)","<p>Creates a new document from the specified file or uri.\n<p>Parameters:\n\n<pre>path - Path to file\nencoding - The document ...</pre>\n"],["file","LibXML::XML::HTMLParser","LibXML/XML/HTMLParser.html#method-c-file","(path, encoding: nil, options: nil)","<p>Creates a new parser by parsing the specified file or uri.\n<p>Parameters:\n\n<pre>path - Path to file to parse\nencoding ...</pre>\n"],["file","LibXML::XML::HTMLParser::Context","LibXML/XML/HTMLParser/Context.html#method-c-file","(p1, p2 = v2)","<p>Creates a new parser context based on the specified file or uri.\n<p>Parameters:\n\n<pre>file - A filename or uri\noptions ...</pre>\n"],["file","LibXML::XML::Parser","LibXML/XML/Parser.html#method-c-file","(path, base_uri: nil, encoding: nil, options: nil)","<p>Creates a new parser for the specified file or uri.\n<p>Parameters:\n\n<pre>path - Path to file\nbase_uri - The base ...</pre>\n"],["file","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-c-file","(p1, p2 = v2)","<p>Creates a new parser context based on the specified file or uri.\n<p>Parameters:\n\n<pre>file - A filename or uri\noptions ...</pre>\n"],["file","LibXML::XML::Reader","LibXML/XML/Reader.html#method-c-file","(p1, p2 = v2)","<p>Creates a new reader by parsing the specified file or uri.\n<p>You may provide an optional hash table to control …\n"],["file","LibXML::XML::SaxParser","LibXML/XML/SaxParser.html#method-c-file","(path)","<p>Creates a new parser by parsing the specified file or uri.\n"],["file","LibXML::XML::Writer","LibXML/XML/Writer.html#method-c-file","(p1)","<p>Creates a XML::Writer object which will write XML into the file with the given name.\n"],["find","LibXML::XML::Document","LibXML/XML/Document.html#method-i-find","(xpath, nslist = nil)","<p>Return the nodes matching the specified xpath expression, optionally using the specified namespace.  …\n"],["find","LibXML::XML::Node","LibXML/XML/Node.html#method-i-find","(xpath, nslist = nil)","<p>Return nodes matching the specified xpath expression. For more information, please refer to the documentation …\n"],["find","LibXML::XML::XPath::Context","LibXML/XML/XPath/Context.html#method-i-find","(p1)","<p>Executes the provided xpath function.  The result depends on the execution of the xpath statement.   …\n"],["find_by_href","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-i-find_by_href","(p1)","<p>Searches for a namespace that has the specified href. The search starts at the current node and works …\n"],["find_by_prefix","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-i-find_by_prefix","(p1)","<p>Searches for a namespace that has the specified prefix. The search starts at the current node and works …\n"],["find_first","LibXML::XML::Document","LibXML/XML/Document.html#method-i-find_first","(xpath, nslist = nil)","<p>Return the first node matching the specified xpath expression. For more information, please refer to …\n"],["find_first","LibXML::XML::Node","LibXML/XML/Node.html#method-i-find_first","(xpath, nslist = nil)","<p>Return the first node matching the specified xpath expression. For more information, please refer to …\n"],["first","LibXML::XML::Attributes","LibXML/XML/Attributes.html#method-i-first","()","<p>Returns the first attribute.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span>.<span class=\"ruby-identifier\">root</span>.<span class=\"ruby-identifier\">attributes</span>.<span class=\"ruby-identifier\">first</span>\n</pre>\n"],["first","LibXML::XML::Node","LibXML/XML/Node.html#method-i-first","()","<p>Returns this node’s first child node if any.\n"],["first","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-first","()","<p>Returns the first node in this node set, or nil if none exist.\n"],["first?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-first-3F","()","<p>Determines whether this node has a first node\n"],["flush","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-flush","(p1 = v1)","<p>Flushes the output buffer. Returns the number of written bytes or the current content of the internal …\n"],["fragment?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-fragment-3F","()","<p>Specifies if this is a fragment node\n"],["from_s","LibXML::XML::Encoding","LibXML/XML/Encoding.html#method-c-from_s","(p1)","<p>Converts an encoding string to an encoding constant defined on the XML::Encoding class.\n"],["from_string","LibXML::XML::RelaxNG","LibXML/XML/RelaxNG.html#method-c-from_string","(p1)","<p>Create a new relaxng using the specified string.\n"],["from_string","LibXML::XML::Schema","LibXML/XML/Schema.html#method-c-from_string","(p1)","<p>Create a new schema using the specified string.\n"],["full_end_element","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-full_end_element","()","<p>Ends current element, namespaced or not. Returns <code>false</code> on failure. This method writes an end tag even …\n"],["get_attribute","LibXML::XML::Attributes","LibXML/XML/Attributes.html#method-i-get_attribute","(p1)","<p>Returns the specified attribute.  If the attribute does not exist but the document has an associated …\n"],["get_attribute","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-get_attribute","(p1)","<p>Provide the value of the attribute with the specified name relative to the containing element.\n"],["get_attribute_no","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-get_attribute_no","(p1)","<p>Provide the value of the attribute with the specified index relative to the containing element.\n"],["get_attribute_ns","LibXML::XML::Attributes","LibXML/XML/Attributes.html#method-i-get_attribute_ns","(p1, p2)","<p>Returns the specified attribute.  If the attribute does not exist but the document has an associated …\n"],["get_attribute_ns","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-get_attribute_ns","(p1, p2)",""],["get_handler","LibXML::XML::Error","LibXML/XML/Error.html#method-c-get_handler","()","<p>Returns the proc that will be called when libxml generates warning, error or fatal error messages.\n"],["has_attributes?","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-has_attributes-3F","()","<p>Get whether the node has attributes.\n"],["has_value?","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-has_value-3F","()","<p>Get whether the node can have a text value.\n"],["href","LibXML::XML::Namespace","LibXML/XML/Namespace.html#method-i-href","()","<p>Usage:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">string</span>(<span class=\"ruby-string\">&#39;&lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;/&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["html?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-html-3F","()","<p>Determine whether this is an html context.\n"],["html_doc?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-html_doc-3F","()","<p>Specifies if this is a html document node\n"],["import","LibXML::XML::Document","LibXML/XML/Document.html#method-i-import","(p1)","<p>Creates a copy of the node that can be inserted into the current document.\n<p>IMPORTANT - The returned node …\n"],["imported_ns_elements","LibXML::XML::Schema","LibXML/XML/Schema.html#method-i-imported_ns_elements","()","<p>Returns a hash by namespace of a hash of schema elements within the entire schema including imports\n"],["imported_ns_types","LibXML::XML::Schema","LibXML/XML/Schema.html#method-i-imported_ns_types","()","<p>Returns a hash by namespace of a hash of schema types within the entire schema including imports\n"],["imported_types","LibXML::XML::Schema","LibXML/XML/Schema.html#method-i-imported_types","()","<p>Returns a hash of all types within the entire schema including imports\n"],["indent_tree_output","LibXML::XML","LibXML/XML.html#method-c-indent_tree_output","()","<p>Determines whether XML output will be indented (using the string supplied to <code>default_indent_tree_string</code> …\n"],["indent_tree_output=","LibXML::XML","LibXML/XML.html#method-c-indent_tree_output-3D","(p1)","<p>Controls whether XML output will be indented (using the string supplied to <code>default_indent_tree_string</code> …\n"],["inner_xml","LibXML::XML::Node","LibXML/XML/Node.html#method-i-inner_xml","(options = Hash.new)","<p>Converts a node’s children to a string representation.  To include the node, use XML::Node#to_s. …\n"],["io","LibXML::XML::Document","LibXML/XML/Document.html#method-c-io","(value, options = {})","<p>Creates a new document from the specified io object.\n<p>Parameters:\n\n<pre>io - io object that contains the xml to ...</pre>\n"],["io","LibXML::XML::HTMLParser","LibXML/XML/HTMLParser.html#method-c-io","(io, base_uri: nil, encoding: nil, options: nil)","<p>Creates a new reader by parsing the specified io object.\n<p>Parameters:\n\n<pre>io - io object that contains the xml ...</pre>\n"],["io","LibXML::XML::HTMLParser::Context","LibXML/XML/HTMLParser/Context.html#method-c-io","(p1, p2 = v2)","<p>Creates a new parser context based on the specified io object.\n<p>Parameters:\n\n<pre>io - A ruby IO object\noptions ...</pre>\n"],["io","LibXML::XML::Parser","LibXML/XML/Parser.html#method-c-io","(io, base_uri: nil, encoding: nil, options: nil)","<p>Creates a new parser for the specified io object.\n<p>Parameters:\n\n<pre>io - io object that contains the xml to parser ...</pre>\n"],["io","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-c-io","(p1, p2 = v2)","<p>Creates a new parser context based on the specified io object.\n<p>Parameters:\n\n<pre>io - A ruby IO object\noptions ...</pre>\n"],["io","LibXML::XML::Reader","LibXML/XML/Reader.html#method-c-io","(p1, p2 = v2)","<p>Creates a new reader by parsing the specified io object.\n<p>You may provide an optional hash table to control …\n"],["io","LibXML::XML::SaxParser","LibXML/XML/SaxParser.html#method-c-io","(io, options = {})","<p>Creates a new reader by parsing the specified io object.\n<p>Parameters:\n\n<pre>encoding - The document encoding, ...</pre>\n"],["io","LibXML::XML::Writer","LibXML/XML/Writer.html#method-c-io","(p1)","<p>Creates a XML::Writer which will write XML directly into an IO object.\n"],["io_max_num_streams","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-io_max_num_streams","()","<p>Obtain the limit on the number of IO streams opened in this context.\n"],["io_num_streams","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-io_num_streams","()","<p>Obtain the actual number of IO streams in this context.\n"],["keep_blanks?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-keep_blanks-3F","()","<p>Determine whether parsers in this context retain whitespace.\n"],["kind_name","LibXML::XML::Schema::Type","LibXML/XML/Schema/Type.html#method-i-kind_name","()",""],["lang","LibXML::XML::Node","LibXML/XML/Node.html#method-i-lang","()","<p>Obtain the language set for this node, if any. This is set in XML via the xml:lang attribute.\n"],["lang=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-lang-3D","(p1)","<p>Set the language for this node. This affects the value of the xml:lang attribute.\n"],["last","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-last","()","<p>Obtain the last attribute.\n"],["last","LibXML::XML::Document","LibXML/XML/Document.html#method-i-last","()","<p>Obtain the last node.\n"],["last","LibXML::XML::Node","LibXML/XML/Node.html#method-i-last","()","<p>Obtain the last child node of this node, if any.\n"],["last","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-last","()","<p>Returns the last node in this node set, or nil if none exist.\n"],["last?","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-last-3F","()","<p>Determine whether this is the last attribute.\n"],["last?","LibXML::XML::Document","LibXML/XML/Document.html#method-i-last-3F","()","<p>Determine whether there is a last node.\n"],["last?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-last-3F","()","<p>Determines whether this node has a last node\n"],["length","LibXML::XML::Attributes","LibXML/XML/Attributes.html#method-i-length","()","<p>Returns the number of attributes.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span>.<span class=\"ruby-identifier\">root</span>.<span class=\"ruby-identifier\">attributes</span>.<span class=\"ruby-identifier\">length</span>\n</pre>\n"],["length","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-length","()","<p>Obtain the length of the nodesetval node list.\n"],["level_to_s","LibXML::XML::Error","LibXML/XML/Error.html#method-i-level_to_s","()",""],["line_num","LibXML::XML::Node","LibXML/XML/Node.html#method-i-line_num","()","<p>Obtain the line number (in the XML document) that this node was read from. If <code>default_line_numbers</code> is …\n"],["line_number","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-line_number","()","<p>Provide the line number of the current parsing point.\n"],["local_name","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-local_name","()","<p>Return the local name of the node.\n"],["lookup_namespace","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-lookup_namespace","(p1)","<p>Resolve a namespace prefix in the scope of the current element. To return the default namespace, specify …\n"],["max_occurs","LibXML::XML::Schema::Element","LibXML/XML/Schema/Element.html#method-i-max_occurs","()",""],["memory_dump","LibXML::XML","LibXML/XML.html#method-c-memory_dump","()","<p>Perform a parser memory dump (requires memory debugging support in libxml).\n"],["memory_used","LibXML::XML","LibXML/XML.html#method-c-memory_used","()","<p>Perform a parser memory dump (requires memory debugging support in libxml).\n"],["min_occurs","LibXML::XML::Schema::Element","LibXML/XML/Schema/Element.html#method-i-min_occurs","()",""],["move_to_attribute","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-move_to_attribute","(p1)","<p>Move the position of the current instance to the attribute with the specified name relative to the containing …\n"],["move_to_attribute_no","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-move_to_attribute_no","(p1)","<p>Move the position of the current instance to the attribute with the specified index relative to the containing …\n"],["move_to_attribute_ns","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-move_to_attribute_ns","(p1, p2)","<p>Move the position of the current instance to the attribute with the specified name and namespace relative …\n"],["move_to_element","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-move_to_element","()","<p>Move the position of the current instance to the node that contains the current attribute node.\n"],["move_to_first_attribute","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-move_to_first_attribute","()","<p>Move the position of the current instance to the first attribute associated with the current node.\n"],["move_to_next_attribute","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-move_to_next_attribute","()","<p>Move the position of the current instance to the next attribute associated with the current node.\n"],["name","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-name","()","<p>Obtain this attribute’s name.\n"],["name","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-name","()","<p>Obtain this attribute declaration’s name.\n"],["name","LibXML::XML::Dtd","LibXML/XML/Dtd.html#method-i-name","()","<p>Obtain this dtd’s name.\n"],["name","LibXML::XML::Node","LibXML/XML/Node.html#method-i-name","()","<p>Obtain this node’s name.\n"],["name","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-name","()","<p>Return the qualified name of the node.\n"],["name=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-name-3D","(p1)","<p>Set this node’s name.\n"],["name_depth","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-name_depth","()","<p>Obtain the name depth for this context.\n"],["name_depth_max","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-name_depth_max","()","<p>Obtain the maximum name depth for this context.\n"],["name_node","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-name_node","()","<p>Obtain the name node for this context.\n"],["name_tab","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-name_tab","()","<p>Obtain the name table for this context.\n"],["namespace","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-i-namespace","()","<p>Returns the current node’s namespace.\n<p>Usage:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">string</span>(<span class=\"ruby-string\">&#39;&lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;/&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["namespace=","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-i-namespace-3D","(p1)","<p>Sets the current node’s namespace.\n<p>Basic usage:\n\n<pre class=\"ruby\"><span class=\"ruby-comment\"># Create a node</span>\n<span class=\"ruby-identifier\">node</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Node</span>.<span class=\"ruby-identifier\">new</span>(<span class=\"ruby-string\">&#39;Envelope&#39;</span>)\n\n<span class=\"ruby-comment\"># ...</span>\n</pre>\n"],["namespace?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-namespace-3F","()","<p>Specifies if this is a namespace node (not if it has a namepsace)\n"],["namespace_declaration?","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-namespace_declaration-3F","()","<p>Determine whether the current node is a namespace declaration rather than a regular attribute.\n"],["namespace_uri","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-namespace_uri","()","<p>Determine the namespace URI of the node.\n"],["namespaces","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-namespaces","()","<p>Returns this node’s XML::Namespaces object, which is used to access the namespaces associated with …\n"],["namespaces","LibXML::XML::Node","LibXML/XML/Node.html#method-i-namespaces","()","<p>Returns this node’s XML::Namespaces object, which is used to access the namespaces associated with …\n"],["namespaces","LibXML::XML::Schema","LibXML/XML/Schema.html#method-i-namespaces","()","<p>Returns an array of Namespaces defined by the schema\n"],["new","LibXML::XML::Attr","LibXML/XML/Attr.html#method-c-new","(*args)","<p>Creates a new attribute for the node.\n<p>node: The XML::Node that will contain the attribute name: The name …\n"],["new","LibXML::XML::Document","LibXML/XML/Document.html#method-c-new","(p1 = v1)","<p>Initializes a new XML::Document, optionally specifying the XML version.\n"],["new","LibXML::XML::Dtd","LibXML/XML/Dtd.html#method-c-new","(p1, p2, p3, p4 = v4, p5 = v5)","<p>Create a new Dtd from the specified public and system identifiers.\n"],["new","LibXML::XML::HTMLParser","LibXML/XML/HTMLParser.html#method-c-new","(p1 = v1)","<p>Initializes a new parser instance with no pre-determined source.\n"],["new","LibXML::XML::Namespace","LibXML/XML/Namespace.html#method-c-new","(p1, p2, p3)","<p>Create a new namespace and adds it to the specified node. Note this does <strong>not</strong> assign the node to the namespace. …\n"],["new","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-c-new","(p1)","<p>Creates a new namespaces object.  Generally you do not call this method directly, but instead access …\n"],["new","LibXML::XML::Node","LibXML/XML/Node.html#method-c-new","(p1, p2 = v2, p3 = v3)","<p>Creates a new element with the specified name, content and namespace. The content and namespace may be …\n"],["new","LibXML::XML::Parser","LibXML/XML/Parser.html#method-c-new","(p1 = v1)","<p>Creates a new XML::Parser from the specified XML::Parser::Context.\n"],["new","LibXML::XML::RelaxNG","LibXML/XML/RelaxNG.html#method-c-new","(p1)","<p>Create a new relaxng from the specified URI.\n"],["new","LibXML::XML::SaxParser","LibXML/XML/SaxParser.html#method-c-new","(p1 = v1)","<p>Creates a new XML::Parser from the specified XML::Parser::Context.\n"],["new","LibXML::XML::Schema","LibXML/XML/Schema.html#method-c-new","(p1)","<p>Create a new schema from the specified URI.\n"],["new","LibXML::XML::XPath::Context","LibXML/XML/XPath/Context.html#method-c-new","(p1)","<p>Creates a new XPath context for the specified document.  The context can then be used to evaluate an …\n"],["new","LibXML::XML::XPath::Expression","LibXML/XML/XPath/Expression.html#method-c-new","(p1)","<p>Compiles an XPath expression. This improves performance when an XPath expression is called multiple times. …\n"],["new_cdata","LibXML::XML::Node","LibXML/XML/Node.html#method-c-new_cdata","(p1 = v1)","<p>Create a new #CDATA node, optionally setting the node’s content.\n"],["new_comment","LibXML::XML::Node","LibXML/XML/Node.html#method-c-new_comment","(p1 = v1)","<p>Create a new comment node, optionally setting the node’s content.\n"],["new_pi","LibXML::XML::Node","LibXML/XML/Node.html#method-c-new_pi","(p1, p2 = v2)","<p>Create a new pi node, optionally setting the node’s content.\n"],["new_text","LibXML::XML::Node","LibXML/XML/Node.html#method-c-new_text","(p1)","<p>Create a new text node.\n"],["next","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-next","()","<p>Obtain the next attribute.\n"],["next","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-next","()","<p>Obtain the next attribute declaration.\n"],["next","LibXML::XML::Document","LibXML/XML/Document.html#method-i-next","()","<p>Obtain the next node.\n"],["next","LibXML::XML::Namespace","LibXML/XML/Namespace.html#method-i-next","()","<p>Obtain the next namespace.\n<p>Usage:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">string</span>(<span class=\"ruby-string\">&#39;&lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;/&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["next","LibXML::XML::Node","LibXML/XML/Node.html#method-i-next","()","<p>Returns the next sibling node if one exists.\n"],["next","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-next","()","<p>Skip to the node following the current one in document order while avoiding the subtree if any.\n"],["next=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-next-3D","(p1)","<p>Adds the specified node as the next sibling of the current node. If the node already exists in the document, …\n"],["next?","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-next-3F","()","<p>Determine whether there is a next attribute.\n"],["next?","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-next-3F","()","<p>Determine whether there is a next attribute declaration.\n"],["next?","LibXML::XML::Document","LibXML/XML/Document.html#method-i-next-3F","()","<p>Determine whether there is a next node.\n"],["next?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-next-3F","()","<p>Determines whether this node has a next node\n"],["next_sibling","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-next_sibling","()","<p>Skip to the node following the current one in document order while avoiding the subtree if any. Currently …\n"],["node","LibXML::XML::Attributes","LibXML/XML/Attributes.html#method-i-node","()","<p>Return the node that owns this attributes list.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span>.<span class=\"ruby-identifier\">root</span>.<span class=\"ruby-identifier\">attributes</span>.<span class=\"ruby-identifier\">node</span> <span class=\"ruby-operator\">==</span> <span class=\"ruby-identifier\">doc</span>.<span class=\"ruby-identifier\">root</span>\n</pre>\n"],["node","LibXML::XML::Namespaces","LibXML/XML/Namespaces.html#method-i-node","()","<p>Returns the current node.\n"],["node","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-node","()","<p>Obtain the root node of this context.\n"],["node","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-node","()","<p>Returns the reader’s current node.  It will return nil if Reader#read has not yet been called. WARNING …\n"],["node","LibXML::XML::Schema::Attribute","LibXML/XML/Schema/Attribute.html#method-i-node","()",""],["node","LibXML::XML::Schema::Element","LibXML/XML/Schema/Element.html#method-i-node","()",""],["node","LibXML::XML::Schema::Facet","LibXML/XML/Schema/Facet.html#method-i-node","()","<p>START FACET\n"],["node","LibXML::XML::Schema::Type","LibXML/XML/Schema/Type.html#method-i-node","()",""],["node=","LibXML::XML::XPath::Context","LibXML/XML/XPath/Context.html#method-i-node-3D","(p1)","<p>Set the current node used by the XPath engine\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">string</span>(<span class=\"ruby-string\">&#39;&lt;header&gt;&lt;first&gt;hi&lt;/first&gt;&lt;/header&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["node_depth","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-node_depth","()","<p>Obtain the node depth for this context.\n"],["node_depth_max","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-node_depth_max","()","<p>Obtain the maximum node depth for this context.\n"],["node_type","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-node_type","()","<p>Obtain this node’s type identifier.\n"],["node_type","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-node_type","()","<p>Obtain this attribute declaration’s type node type.\n"],["node_type","LibXML::XML::Document","LibXML/XML/Document.html#method-i-node_type","()","<p>Obtain this node’s type identifier.\n"],["node_type","LibXML::XML::Dtd","LibXML/XML/Dtd.html#method-i-node_type","()","<p>Obtain this node’s type identifier.\n"],["node_type","LibXML::XML::Namespace","LibXML/XML/Namespace.html#method-i-node_type","()","<p>Obtain this namespace’s type identifier.\n"],["node_type","LibXML::XML::Node","LibXML/XML/Node.html#method-i-node_type","()","<p>Obtain this node’s type identifier.\n"],["node_type","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-node_type","()","<p>Get the node type of the current node. Reference: dotgnu.org/pnetlib-doc/System/Xml/XmlNodeType.html …\n"],["node_type_name","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-node_type_name","()","<p>Returns this node’s type name\n"],["node_type_name","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-node_type_name","()","<p>Returns this attribute declaration’s node type name.\n"],["node_type_name","LibXML::XML::Document","LibXML/XML/Document.html#method-i-node_type_name","()","<p>Returns this node’s type name \n"],["node_type_name","LibXML::XML::Node","LibXML/XML/Node.html#method-i-node_type_name","()","<p>Returns this node’s type name \n"],["normalization","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-normalization","()","<p>The value indicating whether to normalize white space and attribute values. Since attribute value and …\n"],["notation?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-notation-3F","()","<p>Specifies if this is a notation node\n"],["ns","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-ns","()","<p>Obtain this attribute’s associated XML::NS, if any.\n"],["ns?","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-ns-3F","()","<p>Determine whether this attribute has an associated namespace.\n"],["num_chars","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-num_chars","()","<p>Obtain the number of characters in this context.\n"],["on_cdata_block","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_cdata_block","(cdata)","<p>Called for a CDATA block event.\n"],["on_cdata_block","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_cdata_block","(cdata)","<p>Called for a CDATA block event.\n"],["on_characters","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_characters","(chars)","<p>Called for a characters event.\n"],["on_characters","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_characters","(chars)","<p>Called for a characters event.\n"],["on_comment","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_comment","(msg)","<p>Called for a comment event.\n"],["on_comment","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_comment","(comment)","<p>Called for a comment event.\n"],["on_end_document","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_end_document","()","<p>Called for a end document event.\n"],["on_end_document","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_end_document","()","<p>Called for a end document event.\n"],["on_end_element_ns","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_end_element_ns","(name, prefix, uri)","<p>Called for a end element event.\n"],["on_end_element_ns","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_end_element_ns","(name, prefix, uri)","<p>Called for a end element event.\n"],["on_error","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_error","(msg)","<p>Called for parser errors.\n"],["on_error","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_error","(error)","<p>Called for parser errors.\n"],["on_external_subset","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_external_subset","(name, external_id, system_id)","<p>Called for an external subset event.\n"],["on_external_subset","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_external_subset","(name, external_id, system_id)","<p>Called for an external subset event.\n"],["on_has_external_subset","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_has_external_subset","()","<p>Called for an external subset notification event.\n"],["on_has_external_subset","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_has_external_subset","()","<p>Called for an external subset notification event.\n"],["on_has_internal_subset","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_has_internal_subset","()","<p>Called for an internal subset notification event.\n"],["on_has_internal_subset","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_has_internal_subset","()","<p>Called for an internal subset notification event.\n"],["on_internal_subset","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_internal_subset","(name, external_id, system_id)","<p>Called for an internal subset event.\n"],["on_internal_subset","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_internal_subset","(name, external_id, system_id)","<p>Called for an internal subset event.\n"],["on_is_standalone","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_is_standalone","()","<p>Called for ‘is standalone’ event.\n"],["on_is_standalone","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_is_standalone","()","<p>Called for ‘is standalone’ event.\n"],["on_processing_instruction","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_processing_instruction","(target, data)","<p>Called for an processing instruction event.\n"],["on_processing_instruction","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_processing_instruction","(target, data)","<p>Called for an processing instruction event.\n"],["on_reference","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_reference","(name)","<p>Called for a reference event.\n"],["on_reference","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_reference","(name)","<p>Called for a reference event.\n"],["on_start_document","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_start_document","()","<p>Called for a start document event.\n"],["on_start_document","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_start_document","()","<p>Called for a start document event.\n"],["on_start_element_ns","LibXML::XML::SaxParser::Callbacks","LibXML/XML/SaxParser/Callbacks.html#method-i-on_start_element_ns","(name, attributes, prefix, uri, namespaces)","<p>Called for a start element event.\n"],["on_start_element_ns","LibXML::XML::SaxParser::VerboseCallbacks","LibXML/XML/SaxParser/VerboseCallbacks.html#method-i-on_start_element_ns","(name, attributes, prefix, uri, namespaces)","<p>Called for a start element event.\n"],["options","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-options","()","<p>Returns the parser options for this context.  Multiple options can be combined by using Bitwise OR (|). …\n"],["options=","LibXML::XML::HTMLParser::Context","LibXML/XML/HTMLParser/Context.html#method-i-options-3D","(p1)","<p>Provides control over the execution of a parser.  Valid values are the constants defined on XML::Parser::Options …\n"],["options=","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-options-3D","(p1)","<p>Provides control over the execution of a parser.  Valid values are the constants defined on XML::Parser::Options …\n"],["order_elements!","LibXML::XML::Document","LibXML/XML/Document.html#method-i-order_elements-21","()","<p>Call this routine to speed up XPath computation on static documents. This stamps all the element nodes …\n"],["output_escaping=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-output_escaping-3D","(p1)","<p>Controls whether this text node or the immediate text node children of an element or attribute node escapes …\n"],["output_escaping?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-output_escaping-3F","()","<p>Determine whether this node escapes it’s output or not.\n<p>Text nodes return only <code>true</code> or <code>false</code>.  Element …\n"],["parent","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-parent","()","<p>Obtain this attribute node’s parent.\n"],["parent","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-parent","()","<p>Obtain this attribute declaration’s parent which is an instance of a XML::DTD.\n"],["parent","LibXML::XML::Document","LibXML/XML/Document.html#method-i-parent","()","<p>Obtain the parent node.\n"],["parent","LibXML::XML::Node","LibXML/XML/Node.html#method-i-parent","()","<p>Obtain this node’s parent node, if any.\n"],["parent?","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-parent-3F","()","<p>Determine whether this attribute has a parent.\n"],["parent?","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-parent-3F","()","<p>Determine whether this attribute declaration has a parent .\n"],["parent?","LibXML::XML::Document","LibXML/XML/Document.html#method-i-parent-3F","()","<p>Determine whether there is a parent node.\n"],["parent?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-parent-3F","()","<p>Determines whether this node has a parent node\n"],["parse","LibXML::XML::HTMLParser","LibXML/XML/HTMLParser.html#method-i-parse","()","<p>Parse the input XML and create an XML::Document with it’s content. If an error occurs, XML::Parser::ParseError …\n"],["parse","LibXML::XML::Parser","LibXML/XML/Parser.html#method-i-parse","()","<p>Parse the input XML and create an XML::Document with it’s content. If an error occurs, XML::Parser::ParseError …\n"],["parse","LibXML::XML::SaxParser","LibXML/XML/SaxParser.html#method-i-parse","()","<p>Parse the input XML, generating callbacks to the object registered via the <code>callbacks</code> attributesibute. …\n"],["path","LibXML::XML::Node","LibXML/XML/Node.html#method-i-path","()","<p>Obtain this node’s path.\n"],["pi?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-pi-3F","()","<p>Specifies if this is a processiong instruction node\n"],["prefix","LibXML::XML::Namespace","LibXML/XML/Namespace.html#method-i-prefix","()","<p>Obtain the namespace’s prefix.\n<p>Usage:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">string</span>(<span class=\"ruby-string\">&#39;&lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;/&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["prefix","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-prefix","()","<p>Get a shorthand reference to the namespace associated with the node.\n"],["prev","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-prev","()","<p>Obtain the previous attribute.\n"],["prev","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-prev","()","<p>Obtain the previous attribute declaration or the owning element declration (not implemented).\n"],["prev","LibXML::XML::Document","LibXML/XML/Document.html#method-i-prev","()","<p>Obtain the previous node.\n"],["prev","LibXML::XML::Node","LibXML/XML/Node.html#method-i-prev","()","<p>Obtain the previous sibling, if any.\n"],["prev=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-prev-3D","(p1)","<p>Adds the specified node as the previous sibling of the current node. If the node already exists in the …\n"],["prev?","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-prev-3F","()","<p>Determine whether there is a previous attribute.\n"],["prev?","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-prev-3F","()","<p>Determine whether there is a previous attribute declaration.\n"],["prev?","LibXML::XML::Document","LibXML/XML/Document.html#method-i-prev-3F","()","<p>Determine whether there is a previous node.\n"],["prev?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-prev-3F","()","<p>Determines whether this node has a previous node\n"],["quote_char","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-quote_char","()","<p>Get the quotation mark character used to enclose the value of an attribute, as an integer value (and …\n"],["rb_encoding","LibXML::XML::Document","LibXML/XML/Document.html#method-i-rb_encoding","()","<p>Returns the Ruby encoding specified by this document (available on Ruby 1.9.x and higher).\n"],["read","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-read","()","<p>Causes the reader to move to the next node in the stream, exposing its properties.\n<p>Returns true if a node …\n"],["read_attribute_value","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-read_attribute_value","()","<p>Parse an attribute value into one or more Text and EntityReference nodes.\n<p>Return 1 in case of success, …\n"],["read_inner_xml","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-read_inner_xml","()","<p>Read the contents of the current node, including child nodes and markup.\n<p>Return a string containing the …\n"],["read_outer_xml","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-read_outer_xml","()","<p>Read the contents of the current node, including child nodes and markup.\n<p>Return a string containing the …\n"],["read_state","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-read_state","()","<p>Get the read state of the reader.\n"],["read_string","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-read_string","()","<p>Read the contents of an element or a text node as a string.\n<p>Return a string containing the contents of …\n"],["recovery=","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-recovery-3D","(p1)","<p>Control whether recovery mode is enabled in this context.\n"],["recovery?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-recovery-3F","()","<p>Determine whether recovery mode is enabled in this context.\n"],["register","LibXML::XML::InputCallbacks","LibXML/XML/InputCallbacks.html#method-c-register","()","<p>Register a new set of I/O callback for handling parser input.\n"],["register_error_handler","LibXML::XML::Parser","LibXML/XML/Parser.html#method-c-register_error_handler","(proc)",""],["register_namespace","LibXML::XML::XPath::Context","LibXML/XML/XPath/Context.html#method-i-register_namespace","(p1, p2)","<p>Register the specified namespace URI with the specified prefix in this context.\n\n<pre>context.register_namespace(&#39;xi&#39;, ...</pre>\n"],["register_namespaces","LibXML::XML::XPath::Context","LibXML/XML/XPath/Context.html#method-i-register_namespaces","(p1)","<p>Register the specified namespaces in this context.  There are three different forms that libxml accepts. …\n"],["register_namespaces_from_node","LibXML::XML::XPath::Context","LibXML/XML/XPath/Context.html#method-i-register_namespaces_from_node","(p1)","<p>Helper method to read in namespaces defined on a node.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">doc</span> = <span class=\"ruby-constant\">XML</span><span class=\"ruby-operator\">::</span><span class=\"ruby-constant\">Document</span>.<span class=\"ruby-identifier\">string</span>(<span class=\"ruby-string\">&#39;&lt;header&gt;&lt;first&gt;hi&lt;/first&gt;&lt;/header&gt;&#39;</span>) <span class=\"ruby-operator\">...</span>\n</pre>\n"],["relax_ng_validate","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-relax_ng_validate","(p1)","<p>Use RelaxNG to validate the document as it is processed. Activation is only possible before the first …\n"],["remove!","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-remove-21","()","<p>Removes this attribute from it’s parent.  Note the attribute and its content is freed and can no …\n"],["remove!","LibXML::XML::Node","LibXML/XML/Node.html#method-i-remove-21","()","<p>Removes this node and its children from the document tree by setting its document, parent and siblings …\n"],["remove_scheme","LibXML::XML::InputCallbacks","LibXML/XML/InputCallbacks.html#method-c-remove_scheme","(p1)","<p>No documentation available.\n"],["replace_entities=","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-replace_entities-3D","(p1)","<p>Control whether external entity replacement is enabled in this context.\n"],["replace_entities?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-replace_entities-3F","()","<p>Determine whether external entity replacement is enabled in this context.\n"],["required?","LibXML::XML::Schema::Attribute","LibXML/XML/Schema/Attribute.html#method-i-required-3F","()",""],["required?","LibXML::XML::Schema::Element","LibXML/XML/Schema/Element.html#method-i-required-3F","()",""],["reset_handler","LibXML::XML::Error","LibXML/XML/Error.html#method-c-reset_handler","()","<p>Removes the current error handler.\n"],["result","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-result","()","<p>Returns the associated result object to the XML::Writer creation. A String for a XML::Writer object created …\n"],["root","LibXML::XML::Document","LibXML/XML/Document.html#method-i-root","()","<p>Obtain the root node.\n"],["root=","LibXML::XML::Document","LibXML/XML/Document.html#method-i-root-3D","(p1)","<p>Set the root node.\n"],["save","LibXML::XML::Document","LibXML/XML/Document.html#method-i-save","(p1, p2 = v2)","<p>Saves a document to a file.  You may provide an optional hash table to control how the string is generated. …\n"],["schema_validate","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-schema_validate","(p1)","<p>Use W3C XSD schema to validate the document as it is processed. Activation is only possible before the …\n"],["set_handler","LibXML::XML::Error","LibXML/XML/Error.html#method-c-set_handler","()","<p>Registers a block that will be called with an instance of XML::Error when libxml generates warning, error …\n"],["set_indent","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-set_indent","(p1)","<p>Toggles indentation on or off. Returns <code>false</code> on failure.\n<p>Availability: libxml2 &gt;= 2.6.5\n"],["set_indent_string","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-set_indent_string","(p1)","<p>Sets the string to use to indent each element of the document. Don’t forget to enable indentation …\n"],["set_quote_char","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-set_quote_char","(p1)","<p>Sets the character used to quote attributes. Returns <code>false</code> on failure.\n<p>Notes:\n<p>only “ (default) and …\n"],["sibling=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-sibling-3D","(p1)","<p>Adds the specified node as the end of the current node’s list of siblings.  If the node already exists …\n"],["siblings","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-siblings","(node, &blk)","<p>Iterates nodes and attributes\n"],["size","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-size","()","<p>Obtain the length of the nodesetval node list.\n"],["space_depth","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-space_depth","()","<p>Obtain the space depth for this context.\n"],["space_depth_max","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-space_depth_max","()","<p>Obtain the maximum space depth for this context.\n"],["space_preserve","LibXML::XML::Node","LibXML/XML/Node.html#method-i-space_preserve","()","<p>Determine whether this node preserves whitespace.\n"],["space_preserve=","LibXML::XML::Node","LibXML/XML/Node.html#method-i-space_preserve-3D","(p1)","<p>Control whether this node preserves whitespace.\n"],["standalone","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-standalone","()","<p>Determine the standalone status of the document being read.\n<p>Return 1 if the document was declared to be …\n"],["standalone?","LibXML::XML::Document","LibXML/XML/Document.html#method-i-standalone-3F","()","<p>Determine whether this is a standalone document.\n"],["standalone?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-standalone-3F","()","<p>Determine whether this is a standalone context.\n"],["start_attribute","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_attribute","(p1)","<p>Starts an attribute. Returns <code>false</code> on failure.\n"],["start_attribute_ns","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_attribute_ns","(p1, p2, p3 = v3)","<p>Starts a namespaced attribute. Returns <code>false</code> on failure.\n<p>Note: by default, the xmlns: definition is repeated …\n"],["start_cdata","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_cdata","()","<p>Starts a new CDATA section. Returns <code>false</code> on failure.\n"],["start_comment","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_comment","()","<p>Starts a comment. Returns <code>false</code> on failure. Note: libxml2 &gt;= 2.6.7 required\n"],["start_document","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_document","(p1 = v1)","<p>Starts a new document. Returns <code>false</code> on failure.\n<p>You may provide an optional hash table to control XML …\n"],["start_dtd","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_dtd","(p1, p2 = v2, p3 = v3)","<p>Starts a DTD. Returns <code>false</code> on failure.\n"],["start_dtd_attlist","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_dtd_attlist","(p1)","<p>Starts a DTD attribute list (&lt;!ATTLIST … &gt;). Returns <code>false</code> on failure.\n"],["start_dtd_element","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_dtd_element","(p1)","<p>Starts a DTD element (&lt;!ELEMENT … &gt;). Returns <code>false</code> on failure.\n"],["start_dtd_entity","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_dtd_entity","(p1, p2 = v2)","<p>Starts a DTD entity (&lt;!ENTITY … &gt;). Returns <code>false</code> on failure.\n"],["start_element","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_element","(p1)","<p>Starts a new element. Returns <code>false</code> on failure.\n"],["start_element_ns","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_element_ns","(p1, p2, p3 = v3)","<p>Starts a new namespaced element. Returns <code>false</code> on failure.\n<p>Note: by default, the xmlns: definition is …\n"],["start_pi","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-start_pi","(p1)","<p>Starts a new processing instruction. Returns <code>false</code> on failure.\n"],["stats?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-stats-3F","()","<p>Determine whether this context maintains statistics.\n"],["string","LibXML::XML::Document","LibXML/XML/Document.html#method-c-string","(value, base_uri: nil, encoding: nil, options: nil)","<p>Creates a new document from the specified string.\n<p>Parameters:\n\n<pre>string - String to parse\nbase_uri - The base ...</pre>\n"],["string","LibXML::XML::HTMLParser","LibXML/XML/HTMLParser.html#method-c-string","(string, base_uri: nil, encoding: nil, options: nil)","<p>Creates a new parser by parsing the specified string.\n<p>Parameters:\n\n<pre>string - String to parse\nbase_uri - The ...</pre>\n"],["string","LibXML::XML::HTMLParser::Context","LibXML/XML/HTMLParser/Context.html#method-c-string","(p1, p2 = v2)","<p>Creates a new parser context based on the specified string.\n<p>Parameters:\n\n<pre>string - A string that contains ...</pre>\n"],["string","LibXML::XML::Parser","LibXML/XML/Parser.html#method-c-string","(string, base_uri: nil, encoding: nil, options: nil)","<p>Creates a new parser by parsing the specified string.\n<p>Parameters:\n\n<pre>string - The string to parse\nbase_uri ...</pre>\n"],["string","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-c-string","(p1, p2 = v2)","<p>Creates a new parser context based on the specified string.\n<p>Parameters:\n\n<pre>string - A string that contains ...</pre>\n"],["string","LibXML::XML::Reader","LibXML/XML/Reader.html#method-c-string","(p1, p2 = v2)","<p>Creates a new reader by parsing the specified string.\n<p>You may provide an optional hash table to control …\n"],["string","LibXML::XML::SaxParser","LibXML/XML/SaxParser.html#method-c-string","(string)","<p>Creates a new parser by parsing the specified string.\n"],["string","LibXML::XML::Writer","LibXML/XML/Writer.html#method-c-string","()","<p>Creates a XML::Writer which will write XML into memory, as string.\n"],["string","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-string","()","<p>Returns the original XPath expression as a string.\n"],["subset_external?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-subset_external-3F","()","<p>Determine whether this context is a subset of an external context.\n"],["subset_external_system_id","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-subset_external_system_id","()","<p>Obtain this context’s external subset system identifier. (valid only if either of subset_external …\n"],["subset_external_uri","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-subset_external_uri","()","<p>Obtain this context’s external subset URI. (valid only if either of subset_external? or subset_internal …\n"],["subset_internal?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-subset_internal-3F","()","<p>Determine whether this context is a subset of an internal context.\n"],["subset_internal_name","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-subset_internal_name","()","<p>Obtain this context’s subset name (valid only if either of subset_external? or subset_internal? is …\n"],["system_id","LibXML::XML::Dtd","LibXML/XML/Dtd.html#method-i-system_id","()","<p>Obtain this dtd’s URI (for a SYSTEM or PUBLIC DTD).\n"],["text?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-text-3F","()","<p>Specifies if this is a text node\n"],["to_a","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-to_a","()",""],["to_a","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-to_a","()","<p>Obtain an array of the nodes in this set.\n"],["to_h","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-to_h","()",""],["to_h","LibXML::XML::Attributes","LibXML/XML/Attributes.html#method-i-to_h","()",""],["to_rb_encoding","LibXML::XML::Encoding","LibXML/XML/Encoding.html#method-c-to_rb_encoding","(p1)","<p>Converts an encoding constant defined on the XML::Encoding class to a Ruby encoding object (available …\n"],["to_s","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-to_s","()",""],["to_s","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-to_s","()","<p>Returns a string representation of this attribute declaration.\n"],["to_s","LibXML::XML::Document","LibXML/XML/Document.html#method-i-to_s","(p1 = v1)","<p>Converts a document, and all of its children, to a string representation. You may provide an optional …\n"],["to_s","LibXML::XML::Encoding","LibXML/XML/Encoding.html#method-c-to_s","(p1)","<p>Converts an encoding constant defined on the XML::Encoding class to its text representation.\n"],["to_s","LibXML::XML::Error","LibXML/XML/Error.html#method-i-to_s","()",""],["to_s","LibXML::XML::Namespace","LibXML/XML/Namespace.html#method-i-to_s","()","<p>Returns the string represenation of a namespace.\n<p>Usage:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">namespace</span>.<span class=\"ruby-identifier\">to_s</span>\n</pre>\n"],["to_s","LibXML::XML::Node","LibXML/XML/Node.html#method-i-to_s","(p1 = v1)","<p>Converts a node, and all of its children, to a string representation. To include only the node’s …\n"],["types","LibXML::XML::Schema","LibXML/XML/Schema.html#method-i-types","()",""],["uri","LibXML::XML::Dtd","LibXML/XML/Dtd.html#method-i-uri","()","<p>Obtain this dtd’s URI (for a SYSTEM or PUBLIC DTD).\n"],["url","LibXML::XML::Document","LibXML/XML/Document.html#method-i-url","()","<p>Obtain this document’s source URL, if any.\n"],["valid","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-valid","()","<p>Determine whether this context is valid.\n"],["valid?","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-valid-3F","()","<p>Retrieve the validity status from the parser context.\n"],["validate","LibXML::XML::Document","LibXML/XML/Document.html#method-i-validate","(p1)","<p>Validate this document against the specified XML::DTD. If the document is valid the method returns true. …\n"],["validate?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-validate-3F","()","<p>Determine whether validation is enabled in this context.\n"],["validate_relaxng","LibXML::XML::Document","LibXML/XML/Document.html#method-i-validate_relaxng","(p1)","<p>Validate this document against the specified XML::RelaxNG. If the document is valid the method returns …\n"],["validate_schema","LibXML::XML::Document","LibXML/XML/Document.html#method-i-validate_schema","(p1)","<p>Validate this document against the specified XML::Schema. If the document is valid the method returns …\n"],["value","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-value","()","<p>Obtain the value of this attribute.\n"],["value","LibXML::XML::AttrDecl","LibXML/XML/AttrDecl.html#method-i-value","()","<p>Obtain the default value of this attribute declaration.\n"],["value","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-value","()","<p>Provide the text value of the node if present.\n"],["value=","LibXML::XML::Attr","LibXML/XML/Attr.html#method-i-value-3D","(p1)","<p>Sets the value of this attribute.\n"],["version","LibXML::XML::Document","LibXML/XML/Document.html#method-i-version","()","<p>Obtain the XML version specified by this document.\n"],["version","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-version","()","<p>Obtain this context’s version identifier.\n"],["well_formed?","LibXML::XML::Parser::Context","LibXML/XML/Parser/Context.html#method-i-well_formed-3F","()","<p>Determine whether this context contains well-formed XML.\n"],["write_attribute","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_attribute","(p1, p2)","<p>Writes a full attribute, all at once. Returns <code>false</code> on failure. Same as start_attribute(name) + write_string …\n"],["write_attribute_ns","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_attribute_ns","(p1, p2, p3 = v3, p4 = v4)","<p>Writes a full namespaced attribute, all at once. Returns <code>false</code> on failure. Same as start_attribute_ns …\n"],["write_cdata","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_cdata","(p1)","<p>Writes a full CDATA section, all at once. Returns <code>false</code> on failure. This is equivalent to start_cdata …\n"],["write_comment","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_comment","(p1)","<p>Writes a full comment tag, all at once. Returns <code>false</code> on failure. This is equivalent to start_comment …\n"],["write_dtd","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_dtd","(p1, p2 = v2, p3 = v3, p4 = v4)","<p>Writes a DTD, all at once. Returns <code>false</code> on failure.\n<p>name: dtd name\n<p>publicId: external subset public identifier, …\n"],["write_dtd_attlist","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_dtd_attlist","(p1, p2)","<p>Writes a DTD attribute list, all at once. Returns <code>false</code> on failure.\n\n<pre>writer.write_dtd_attlist &#39;id&#39;, &#39;ID ...</pre>\n"],["write_dtd_element","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_dtd_element","(p1, p2)","<p>Writes a full DTD element, all at once. Returns <code>false</code> on failure.\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">writer</span>.<span class=\"ruby-identifier\">write_dtd_element</span> <span class=\"ruby-string\">&#39;person&#39;</span>, <span class=\"ruby-string\">&#39;(firstname,lastname)&#39;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["write_dtd_entity","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_dtd_entity","(p1, p2, p3, p4, p5, p6)","<p>Writes a DTD entity, all at once. Returns <code>false</code> on failure.\n"],["write_dtd_external_entity","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_dtd_external_entity","(p1, p2, p3, p4, p5)","<p>Writes a DTD external entity. The entity must have been started with start_dtd_entity. Returns <code>false</code> …\n"],["write_dtd_external_entity_contents","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_dtd_external_entity_contents","(p1, p2, p3)","<p>Writes the contents of a DTD external entity, all at once. Returns <code>false</code> on failure.\n"],["write_dtd_internal_entity","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_dtd_internal_entity","(p1, p2, p3)","<p>Writes a DTD internal entity, all at once. Returns <code>false</code> on failure.\n<p>Examples:\n\n<pre class=\"ruby\"><span class=\"ruby-identifier\">writer</span>.<span class=\"ruby-identifier\">write_dtd_entity</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["write_dtd_notation","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_dtd_notation","(p1, p2, p3)","<p>Writes a DTD entity, all at once. Returns <code>false</code> on failure.\n"],["write_element","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_element","(p1, p2 = v2)","<p>Writes a full element tag, all at once. Returns <code>false</code> on failure. This is equivalent to start_element …\n"],["write_element_ns","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_element_ns","(p1, p2, p3 = v3, p4 = v4)","<p>Writes a full namespaced element tag, all at once. Returns <code>false</code> on failure. This is a shortcut for  …\n"],["write_pi","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_pi","(p1, p2)","<p>Writes a full CDATA tag, all at once. Returns <code>false</code> on failure. This is a shortcut for start_pi(target) …\n"],["write_raw","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_raw","(p1)","<p>Writes the string <code>content</code> as is, reserved characters are not translated to their associated entities. …\n"],["write_string","LibXML::XML::Writer","LibXML/XML/Writer.html#method-i-write_string","(p1)","<p>Safely (problematic characters are internally translated to their associated named entities) writes a …\n"],["xhtml?","LibXML::XML::Document","LibXML/XML/Document.html#method-i-xhtml-3F","()","<p>Determine whether this is an XHTML document.\n"],["xinclude","LibXML::XML::Document","LibXML/XML/Document.html#method-i-xinclude","()","<p>Process xinclude directives in this document.\n"],["xinclude_end?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-xinclude_end-3F","()","<p>Specifies if this is an xinclude end node\n"],["xinclude_start?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-xinclude_start-3F","()","<p>Specifies if this is an xinclude start node\n"],["xlink?","LibXML::XML::Node","LibXML/XML/Node.html#method-i-xlink-3F","()","<p>Determine whether this node is an xlink node.\n"],["xlink_type","LibXML::XML::Node","LibXML/XML/Node.html#method-i-xlink_type","()","<p>Obtain the type identifier for this xlink, if applicable. If this is not an xlink node (see <code>xlink?</code>), …\n"],["xlink_type_name","LibXML::XML::Node","LibXML/XML/Node.html#method-i-xlink_type_name","()","<p>Obtain the type name for this xlink, if applicable. If this is not an xlink node (see <code>xlink?</code>), will return …\n"],["xml_lang","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-xml_lang","()","<p>Get the xml:lang scope within which the node resides.\n"],["xml_version","LibXML::XML::Reader","LibXML/XML/Reader.html#method-i-xml_version","()","<p>Determine the XML version of the document being read.\n"],["xpath_type","LibXML::XML::XPath::Object","LibXML/XML/XPath/Object.html#method-i-xpath_type","()","<p>Returns the XPath type of the result object. Possible values are defined as constants on the XML::XPath …\n"],["HISTORY","","HISTORY.html","","<p>Release History\n<p>5.0.0 / 2024-01-07\n<p>This release is major version bump because it removes access to global …\n"],["LICENSE","","LICENSE.html","","\n<pre>Copyright (c) 2008-2013 Charlie Savage and contributors\nCopyright (c) 2002-2007 Sean Chittenden and contributors ...</pre>\n"],["README","","README_rdoc.html","","<p>LibXML Ruby\n<p>Overview\n<p>The libxml gem provides Ruby language bindings for GNOME’s Libxml2 XML toolkit. …\n"]]}}